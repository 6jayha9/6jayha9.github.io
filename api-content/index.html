{"posts":[{"title":"spring-security安全认证框架Part1（非OAuth2部分）","content":" spring-security是通过servlet的filter链方式实现的一种认证，授权 快速入门（在内存中使用）； 在内存中的使用非常简单 阅读代码即可 @Configuration @EnableWebSecurity public class securityConfig extends WebSecurityConfigurerAdapter { @Bean public PasswordEncoder passwordEncoder() { // BCryptPasswordEncoder：Spring Security 提供的加密工具，可快速实现加密加盐 return new BCryptPasswordEncoder(); } @Bean public UserDetailsService userDetailsService(){ InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager(); return manager; } /** * 该方法是授权相关方法 * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception { //首页所有人可以访问&quot;/&quot; http.authorizeRequests() .antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/index.html&quot;).permitAll() .antMatchers(&quot;/index&quot;).permitAll() .antMatchers(&quot;/home&quot;).permitAll() .antMatchers(&quot;/welcome&quot;).permitAll() .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;) .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;) .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;) .and().formLogin()//开启自定义页面 .loginPage(&quot;/userlogin&quot;).loginProcessingUrl(&quot;/welcome&quot;).usernameParameter(&quot;username&quot;).passwordParameter(&quot;password&quot;). failureHandler((req, resp, exception) -&gt; { resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(&quot;登录失败...&quot;); out.flush(); }) .permitAll() .and() .httpBasic() .and() // 关闭CSRF跨域 .csrf().disable(); ; //没有权限跳到登录页 /*http.formLogin();*/ //关闭csrf功能 //http.csrf().disable(); //开启注销 成功跳到“/” http.logout().logoutSuccessUrl(&quot;/&quot;); } /** * 该方法是认证相关方法 * @param auth * @throws Exception */ /*@Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { //从内存中读 //使用BCrypt加密 auth.inMemoryAuthentication().passwordEncoder(passwordEncoder()) .withUser(&quot;jayha&quot;).password(passwordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip3&quot;,&quot;vip2&quot;) .and() .withUser(&quot;nanha&quot;).password(passwordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;); }*/ @Override public void configure(WebSecurity web) throws Exception { // 设置拦截忽略url - 会直接过滤该url - 将不会经过Spring Security过滤器链 web.ignoring().antMatchers(&quot;/getUserInfo&quot;); // 设置拦截忽略文件夹，可以对静态资源放行 web.ignoring().antMatchers(&quot;/css/**&quot;, &quot;/js/**&quot;); } } BCryptPasswordEncoder 是spring提供的一种特殊加密方式，建议数据库以次类方式存储，有静态方法hashpw(实际密码，盐分值[也可由Bcrypt自动生成]) void testBcrypto(){ String s1 = BCrypt.hashpw(&quot;sir159357&quot;, BCrypt.gensalt()); String s2 = BCrypt.hashpw(&quot;sir159357&quot;, BCrypt.gensalt()); System.out.println(s1); System.out.println(s2); } 结果 s1:$2a$10$WH2U/RLezICmMu8cAN2kQ.vWb46UOEtYbHgMeri8bc4JHGtKVGSKy s2:$2a$10$aLTNf4pFC3OwyEM/r.9aeepuid9efVaLlvdqpNEDO01vPX.17kc0O 所以配置一个名为passwordEncoder的bean 该bean返回的值 就是security的编码方式 @Bean public PasswordEncoder passwordEncoder() { // BCryptPasswordEncoder：Spring Security 提供的加密工具，可快速实现加密加盐 return new BCryptPasswordEncoder(); } 接下来 我们就可以从内存过渡到数据库了 回到springsecurity流程图 我们可以发现认证是由一个叫做UserDetailsService的接口进行实现的。我们可以实现这个接口并把ta加入到IOC容器中 @Service public class userdetailService implements UserDetailsService { @Autowired ItestuserDAO itestuserDAO; @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException { testuser one = itestuserDAO.findOneByAccount(s); if(one == null){ return null;//不用自己抛出异常 返回NULL spring=security会自动整理 }else{ UserDetails details = User.withUsername(one.getAccount()).password(one.getPassword()).authorities(&quot;vip1&quot;).build();//withusername方法即把username加入 password同理，authorities则是将用户进行授权操作 return details; } } } 注意的是这里给用户授权的是auth 而在SecurityConfig里面是授权的role 二者是不同授权理念的具体实现，现在一般是role（角色）包含auth（权限）这种操作 要注意更改 俺最初没理解好这两个东西的概念在这疯狂踩坑 @Override protected void configure(HttpSecurity http) throws Exception { //首页所有人可以访问&quot;/&quot; http.authorizeRequests() .antMatchers(&quot;/&quot;).permitAll() .antMatchers(&quot;/index.html&quot;).permitAll() .antMatchers(&quot;/index&quot;).permitAll() .antMatchers(&quot;/home&quot;).permitAll() .antMatchers(&quot;/welcome&quot;).permitAll() .antMatchers(&quot;/level1/**&quot;).hasAuthority(&quot;vip1&quot;) .antMatchers(&quot;/level2/**&quot;).hasAuthority(&quot;vip2&quot;) .antMatchers(&quot;/level3/**&quot;).hasAuthority(&quot;vip3&quot;) .and() .formLogin()//开启自定义页面 .loginPage(&quot;/userlogin&quot;) .loginProcessingUrl(&quot;/welcome&quot;) .usernameParameter(&quot;username&quot;) .passwordParameter(&quot;password&quot;) .failureHandler((req, resp, exception) -&gt; { resp.setContentType(&quot;application/json;charset=utf-8&quot;); PrintWriter out = resp.getWriter(); out.write(&quot;登录失败...&quot;); out.flush(); }).permitAll() .and() .httpBasic() .and() // 关闭CSRF跨域 .csrf().disable().cors(); ; http.logout().logoutSuccessUrl(&quot;/&quot;); } 用户登录后获取用户信息 可以使用 Authentication authentication =SecurityContextHolder.getContext().getAuthentication(); Object principal = authentication.getPrincipal(); principal就是UserDetail对象 可以强转后使用它的各种方法 比如获取姓名： @GetMapping(&quot;/getName&quot;) public String getUserAccount(){ String account= null; Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); Object principal = authentication.getPrincipal(); if(principal == null){ account = &quot;匿名&quot;; } if(principal instanceof UserDetails){ UserDetails u = (UserDetails)principal; account = u.getUsername(); } return account; } 数据库的建立 除了用户类外 还要有角色表 与用户表是多对多关系 还要有权限表 和角色表也是多对多关系由于这个sql比较复杂 建议用mybatis 由于我们之后使用token来保持会话，所以 我们可以将session保持会话方式禁用 建议在学了token之后再关 protected void configure(HttpSecurity http) throws Exception {http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);} 方法授权 在配置类上（加了configuration注解的类）使用 @EnableGlobalMethodSecurity(securedEnabled = true ) 开启方法授权 secured注解API支持 @Secured(&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;)//允许匿名访问的方法（即任何人都可以访问） @Secured(&quot;ROLE_xx&quot;)//只有xx角色的可以访问 但不建议使用这个 建议使用prepost注解 @EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true) @PreAuthorize(&quot;isAnonymous()&quot;) 匿名可以访问 @PreAuthorize(&quot;hasAuthority('vip1','vip2')&quot;)有vip1和vip2的可以访问 ","link":"https://jayhablog.vercel.app/spring-security-an-quan-ren-zheng-kuang-jia-1/"},{"title":"springboot集成定时，异步，邮件任务","content":"异步 springboot主类下用@EnableAsync 开启异步 在需要用异步的方法上使用@Async注解，该任务会自动进入一个新进程，自动异步 邮件 jar &lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-mail --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; yaml配置信息 spring: mail: username: your_mail@xx.com password: your_password host: smtp.163.com #example protocol: smtps #example springboot自动装JavaMailSenderImpl的实体类 //源码 @Bean JavaMailSenderImpl mailSender(Session session) { JavaMailSenderImpl sender = new JavaMailSenderImpl(); sender.setDefaultEncoding(this.properties.getDefaultEncoding().name()); sender.setSession(session); return sender; } 按照配置文件的属性进行创建，可以直接注入 @Autowired private JavaMailSenderImpl mailSender; 之后直接用mailsender所提供的各种send进行发送就行 示例： @Test void contextLoads() { SimpleMailMessage mailMessage = new SimpleMailMessage(); mailMessage.setSubject(&quot;早上好&quot;); mailMessage.setText(&quot;goodMoring&quot;); mailMessage.setTo(&quot;send_mail@qq.com&quot;); mailMessage.setFrom(&quot;your_mail@163.com&quot;); mailSender.send(mailMessage); } 若要发送复杂邮件 则可以取消simpleMailMessage类 用 MimeMessage mimeMessage = mailSender.createMimeMessage(); 复杂类对象 MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); helper.setSubject(&quot;早上好&quot;); helper.setText(&quot;&lt;a herf='www.baidu.com' &gt;今天 7:30来开会&lt;/a&gt;&quot;,true); //发送附件 helper.addAttachment(&quot;1.jpg&quot;,new File(&quot;C:\\\\Users\\\\19029\\\\Desktop\\\\杂七杂八~\\\\1.jpg&quot;)); helper.setTo(&quot;1902980268@qq.com&quot;); helper.setFrom(&quot;15999971548@163.com&quot;); mailSender.send(mimeMessage); 定时 项目开发中经常需要执行一些定时任务，比如需要在每天凌晨的时候，分析一次前一天的日志信息，Spring为我们提供了异步执行任务调度的方式，提供了两个接口。 TaskExecutor接口 TaskScheduler接口 两个注解： @EnableScheduling// 主main方法上 表示开启定时任务 @Scheduled//写cron表达式 表示什么时候 ","link":"https://jayhablog.vercel.app/springboot-ji-cheng-ding-shi-yi-bu-you-jian-ren-wu/"},{"title":"swagger初步实践","content":"swagger swagger jar &lt;!--swagger--&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--http://localhost:8080/swagger-ui.html--&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt;--&gt; &lt;!--http://localhost:8080/document.html--&gt; &lt;dependency&gt; &lt;groupId&gt;com.zyplayer&lt;/groupId&gt; &lt;artifactId&gt;swagger-mg-ui&lt;/artifactId&gt; &lt;version&gt;1.0.6&lt;/version&gt; &lt;/dependency&gt; swagger的springboot内类配置 package cn.gdoujayha.springbootApplication.config; import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.core.env.Environment; import org.springframework.core.env.Profiles; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.service.Contact; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; import java.util.ArrayList; import java.util.Properties; @Configuration @EnableSwagger2 public class SwaggerConfig { /** * 联系方式（作者名字，联系url，email） */ private static final Contact CONTACT = new Contact(&quot;jayha&quot;,&quot;https://jayhablog.vercel.app&quot;,&quot;1902980268@qq.com&quot;) ; /* 配置swagger的docket bean实例 */ @Bean /*@ConditionalOnProperty(prefix = &quot;profiles&quot;,havingValue = &quot;dev&quot;)*/ public Docket docket(Environment environment){ Profiles profiles = Profiles.of(&quot;dev&quot;,&quot;test&quot;); boolean flag = environment.acceptsProfiles(profiles);//“仅在dev和test环境下生效” return new Docket(DocumentationType.SWAGGER_2) .groupName(&quot;jayha&quot;)//设置分组名 可以设置多个分组（多人协同的时候，可以一人一个或多个组） .enable(flag) .apiInfo(apiInfo()) .select() /** * apis：配置所需要扫描的地方 * requestHandlerSelectors有方式 * .basePackage配置扫描包 * .any扫描所有地方 * .none全不扫描 * .withClassAnnotation()只扫描类上有加了传入注解class的的那个注解的类（传入注解的class） */ .apis(RequestHandlerSelectors.basePackage(&quot;cn.gdoujayha.springbootApplication.controller&quot;))//配置扫描包 /** * paths配置过滤的路径 * 使用pathselector下的东西 * 下有： * any全部 * none全否 * regex：正则 * ant（一般用这个）路径 */ //.paths(PathSelectors.ant(&quot;/springbootApplication/controller/reginController/**&quot;)) .build() ; } /** * apiinfo的配置 * @return */ private ApiInfo apiInfo(){ return new ApiInfo(&quot;Jayha‘文档&quot;, &quot;关于''项目的swagger文档&quot;, &quot;0.1&quot;, &quot;urn:tos&quot;, CONTACT, &quot;Apache 2.0&quot;, &quot;http://www.apache.org/licenses/LICENSE-2.0&quot;, new ArrayList()); } } 常用注解 Swagger的所有注解定义在io.swagger.annotations包下 下面列一些经常用到的，未列举出来的可以另行查阅说明： Swagger注解 简单说明 @Api(tags = &quot;xxx模块说明&quot;) 作用在模块类上 @ApiOperation(&quot;xxx接口说明&quot;) 作用在接口方法上 @ApiModel(&quot;xxxPOJO说明&quot;) 作用在模型类上：如VO、BO @ApiModelProperty(value = &quot;xxx属性说明&quot;,hidden = true) 作用在类方法和属性上，hidden设置为true可以隐藏该属性 @ApiParam(&quot;xxx参数说明&quot;) 作用在参数、方法和字段上，类似@ApiModelProperty ","link":"https://jayhablog.vercel.app/swagger-chu-bu-shi-jian/"},{"title":"关于本站","content":" 欢迎来到我的小站呀，很高兴遇见你！🤝 🏠 关于本站： 这是Jayha小罗同学无聊之下做的一个简陋博客，旨在分享技术，倾吐垃圾，写矫情文字嘻嘻嘻。 我也不知道我维护多久，可能写几篇之后就不写了（懒鬼本鬼谢谢!）也可能大学四年里一直维护他，将就看吧hhhhh。 ⛹ 兴趣爱好 跳舞唱歌敲代码！！！ 📬 联系我呀 微信号: Jayha_ gitee：https://gitee.com/jayha ","link":"https://jayhablog.vercel.app/guan-yu-ben-zhan/"},{"title":"简易快速springboot整合mybats步骤","content":"导入包不用说 在主运行类上 加上这个注解，表示扫描包 在yaml文件上配置mybatis配置 @MapperScan(basePackages ={&quot;cn.gdouJayha.springbootApplication.dao&quot;}) 在yaml文件上 配置mybatis相关属性设置（部分） mybatis: #起别名 type-aliases-package: cn.gdouJayha.springbootapplication.domain #映射位置 mapper-locations: classpath:mybatis/mapper/*.xml check-config-location: true #主配置xml位置 config-location: classpath:mybatis/SqlMapConfig.xml 更改pom.xml，停止过滤mybatis配置文件 &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;!-- src/main/resources下的指定资源放行 --&gt; &lt;includes&gt; &lt;include&gt;**/*.*&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 如果需要用到事务尽力可以使用注解解决 @Transactional ","link":"https://jayhablog.vercel.app/springboot-zheng-he-mybats-jian-yi/"}]}