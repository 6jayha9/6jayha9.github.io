<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>docker part1 | Jayha小罗的秘密基地</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.0/css/all.min.css">
<link rel="shortcut icon" href="https://jayhablog.vercel.app/favicon.ico?v=1617773609302">
<link rel="stylesheet" href="https://jayhablog.vercel.app/styles/main.css">





<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aos@2.3.4/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="



概念
说明




Docker 镜像(Images)
Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。


Docker 容器(Container)
容器是独立运行的一个或一组应用，是镜像运行时的..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://jayhablog.vercel.app">
        <img src="https://jayhablog.vercel.app/images/avatar.png?v=1617773609302" class="site-logo">
        <h1 class="site-title">Jayha小罗的秘密基地</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="https://jayhablog.vercel.app/guan-yu-ben-zhan" class="site-nav">
            关于本站呢~
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      欢迎来到Jayha小罗的Blog嘻嘻嘻：）
    </div>
    <div class="site-footer">
      <a href="https://gitee.com/jayha" target="_blank">Jayha的Gitee首页</a> | <a class="rss" href="https://jayhablog.vercel.app/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">docker part1</h2>
            <div class="post-date">2021-04-01</div>
            
              <div class="feature-container" style="background-image: url('https://jayhablog.vercel.app/post-images/docker-part1-ji-chu-pian.jpg')">
              </div>
            
            <div class="post-content" v-pre>
              <p><img src="https://jayhablog.vercel.app/post-images/1617254006024.png" alt="" loading="lazy"><img src="D:%5C%E5%9B%BE%E5%BA%8A%5C576507-docker1.png" alt="" loading="lazy"></p>
<table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Docker 镜像(Images)</td>
<td>Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td>
</tr>
<tr>
<td>Docker 容器(Container)</td>
<td>容器是独立运行的一个或一组应用，是镜像运行时的实体。</td>
</tr>
<tr>
<td>Docker 客户端(Client)</td>
<td>Docker 客户端通过命令行或者其他工具使用 Docker SDK (https://docs.docker.com/develop/sdk/) 与 Docker 的守护进程通信。</td>
</tr>
<tr>
<td>Docker 主机(Host)</td>
<td>一个物理或者虚拟的机器用于执行 Docker  守护进程和容器。</td>
</tr>
<tr>
<td>Docker Registry</td>
<td>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。 Docker Hub(https://hub.docker.com) 提供了庞大的镜像集合供使用。  一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。 通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <strong>latest</strong> 作为默认标签。</td>
</tr>
<tr>
<td>Docker Machine</td>
<td>Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</td>
</tr>
</tbody>
</table>
<p><strong>Docker是什么工作的?</strong><br>
Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上。通过<code>Socket</code>从客户端访问! DockerServer接收到 Docker-Client的指令，就会执行这个命令!</p>
<p>docker支持$() 的标记语法 如</p>
<pre><code class="language-shell">docker rm $(docker ps -aq)
</code></pre>
<p>ctrl+p+q 容器不停止退出交互模式</p>
<p>常用命令 查询 https://mp.weixin.qq.com/s/vBsTkAGmwInbLT18qOUZBw</p>
<h2 id="docker镜像加载原理"><strong>Docker镜像加载原理</strong></h2>
<p>docker的镜像实际上由一层一层的文件系统组成，这种展级的文件系统UnionFS.<br>
bootfs(boot file system)主要包含bootloader和kernel,bootloader主要是引导加载kernel,Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs,<br>
rootfs (root fle system)，在bootfs之上。包含的就是典型Linux系统中的/dev/proc/bin,/etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p>
<blockquote>
<p>平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M?</p>
</blockquote>
<p>对于一个精简的Os，rootfs可以很小，只需要包含最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的linux发行版bootfs基本是一致的rootfs会有差别,因此不同的发行版可以公用 bootfs.</p>
<p><img src="https://jayhablog.vercel.app/post-images/1617253972074.png" alt="" loading="lazy"><img src="D:%5C%E5%9B%BE%E5%BA%8A%5C20200320105107961.png" alt="" loading="lazy"></p>
<h4 id="换一个方法来说"><strong>换一个方法来说</strong></h4>
<p>Docker 镜像由一些松耦合的只读镜像层组成。</p>
<p>Docker 负责堆叠这些镜像层，并且将它们表示为单个统一的对象。</p>
<p>查看镜像分层的方式可以通过 docker image inspect 命令。下面同样以 ubuntu:latest 镜像为例。</p>
<p>所有的 Docker 镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p>
<p>举一个简单的例子，假如基于 Ubuntu Linux 16.04 创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加python 包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。</p>
<p>该镜像当前已经包含 3 个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。</p>
<p><img src="https://jayhablog.vercel.app/post-images/1617253896321.gif" alt="" loading="lazy"><img src="D:%5C%E5%9B%BE%E5%BA%8A%5C4-1Z416164115364.gif" alt="" loading="lazy"></p>
<p><strong><code>多个镜像之间可以并且确实会共享镜像层。这样可以有效节省空间并提升性能</code></strong>。</p>
<p>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。下图中举了一个简单的例子，每个镜像层包含 3 个文件，而镜像包含了来自两个镜像层的 6 个文件。</p>
<p><img src="https://jayhablog.vercel.app/post-images/1617253822923.gif" alt="" loading="lazy"><img src="D:%5C%E5%9B%BE%E5%BA%8A%5C4-1Z41616413R94.gif" alt="" loading="lazy"></p>
<p>上图中的镜像层跟之前图中的略有区别，主要目的是便于展示文件。</p>
<p>下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有 6 个文件，这是因为最上层中的文件 7 是文件 5 的一个更新版本。</p>
<p><img src="https://jayhablog.vercel.app/post-images/1617253858775.gif" alt="" loading="lazy"><img src="D:%5C%E5%9B%BE%E5%BA%8A%5C4-1Z416164203H1.gif" alt="" loading="lazy"></p>
<p>这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中。</p>
<p>Docker 通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。</p>
<p>Linux 上可用的存储引擎有 AUFS、Overlay2、Device Mapper、Btrfs 以及 ZFS。顾名思义，每种存储引擎都基于 Linux 中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。</p>
<p>Docker 在 Windows 上仅支持 windowsfilter 一种存储引擎，该引擎基于 NTFS 文件系统之上实现了分层和 CoW[1]。</p>
<p>下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。</p>
<figure data-type="image" tabindex="1"><img src="http://c.biancheng.net/uploads/allimg/190416/4-1Z4161642301E.gif" alt="从系统角度看三层镜像" loading="lazy"></figure>
<p>回顾一下之前用于拉取 nigelpoulton/tu-demo 仓库下全部包含标签的 docker image pull 命令（包含 -a 参数）。</p>
<pre><code class="language-bash">$ docker image pull -a nigelpoulton/tu-demo
 
 latest: Pulling from nigelpoulton/tu-demo
 237d5fcd25cf: Pull complete
 a3ed95caeb02: Pull complete
 &lt;Snip&gt;
 Digest: sha256:42e34e546cee61adb100...a0c5b53f324a9e1c1aae451e9
 
 v1: Pulling from nigelpoulton/tu-demo
 237d5fcd25cf: Already exists
 a3ed95caeb02: Already exists
 &lt;Snip&gt;
 Digest: sha256:9ccc0c67e5c5eaae4beb...24c1d5c80f2c9623cbcc9b59a
 
 v2: Pulling from nigelpoulton/tu-demo
 237d5fcd25cf: Already exists
 a3ed95caeb02: Already exists
 &lt;Snip&gt;
 eab5aaac65de: Pull complete
 Digest: sha256:d3c0d8c9d5719d31b79c...fef58a7e038cf0ef2ba5eb74c
 
 Status: Downloaded newer image for nigelpoulton/tu-demo
 
 $ docker image ls
 REPOSITORY TAG IMAGE ID CREATED SIZE
 nigelpoulton/tu-demo v2 6ac...ead 4 months ago 211.6 MB
 nigelpoulton/tu-demo latest 9b9...e29 4 months ago 211.6 MB
 nigelpoulton/tu-demo v1 9b9...e29 4 months ago 211.6 MB
</code></pre>
<p>注意那些以 Already exists 结尾的行。</p>
<p>由这几行可见，Docker 很聪明，可以识别出要拉取的镜像中，哪几层已经在本地存在。</p>
<p>在本例中，Docker 首先尝试拉取标签为 latest 的镜像。然后，当拉取标签为 v1 和 v2 的镜像时，Docker 注意到组成这两个镜像的镜像层，有一部分已经存在了。出现这种情况的原因是前面 3 个镜像相似度很高，所以共享了很多镜像层。</p>
<p>如前所述，Docker 在 Linux 上支持很多存储引擎（Snapshotter）。每个存储引擎都有自己的镜像分层、镜像层共享以及写时复制（CoW）技术的具体实现。</p>
<h1 id="容器和虚拟机">容器和虚拟机</h1>
<p>容器和虚拟机都依赖于宿主机才能运行。宿主机可以是笔记本，是数据中心的物理服务器，也可以是公有云的某个实例。</p>
<p>在下面的示例中，假设宿主机是一台需要运行 4 个业务应用的物理服务器。</p>
<p>在虚拟机模型中，首先要开启物理机并启动 Hypervisor 引导程序。一旦 Hypervisor 启动，就会占有机器上的全部物理资源，如 CPU、RAM、存储和 NIC。</p>
<p>Hypervisor 接下来就会将这些物理资源划分为虚拟资源，并且看起来与真实物理资源完全一致。</p>
<p>然后 Hypervisor 会将这些资源打包进一个叫作虚拟机（VM）的软件结构当中。这样用户就可以使用这些虚拟机，并在其中安装操作系统和应用。</p>
<p>前面提到需要在物理机上运行 4 个应用，所以在 Hypervisor 之上需要创建 4 个虚拟机并安装 4 个操作系统，然后安装 4 个应用。当操作完成后，结构如下图所示。</p>
<figure data-type="image" tabindex="2"><img src="http://c.biancheng.net/uploads/allimg/190417/4-1Z41G01336346.gif" alt="运行4个业务应用的物理服务器" loading="lazy"></figure>
<p>而容器模型则略有不同。</p>
<p>服务器启动之后，所选择的操作系统会启动。在 Docker 世界中可以选择 Linux，或者内核支持内核中的容器原语的新版本 Windows。</p>
<p>与虚拟机模型相同，OS 也占用了全部硬件资源。在 OS 层之上，需要安装容器引擎（如 Docker）。</p>
<p>容器引擎可以获取系统资源，比如进程树、文件系统以及网络栈，接着将资源分割为安全的互相隔离的资源结构，称之为容器。</p>
<p>每个容器看起来就像一个真实的操作系统，在其内部可以运行应用。按照前面的假设，需要在物理机上运行 4 个应用。</p>
<p>因此，需要划分出 4 个容器并在每个容器中运行一个应用，如下图所示。</p>
<figure data-type="image" tabindex="3"><img src="http://c.biancheng.net/uploads/allimg/190417/4-1Z41G01424234.gif" alt="划分4个容器" loading="lazy"></figure>
<p>从更高层面上来讲，Hypervisor 是硬件虚拟化（Hardware Virtualization）——Hypervisor 将硬件物理资源划分为虚拟资源。</p>
<p>容器是操作系统虚拟化（OS Virtualization）——容器将系统资源划分为虚拟资源。</p>
<h1 id="虚拟机的额外开销">虚拟机的额外开销</h1>
<p>基于前文所述内容，接下来会着重探讨 Hypervisor 模型的一个主要问题。</p>
<p>首先我们的目标是在一台物理机上运行 4 个业务相关应用。每种模型示例中都安装了一个操作系统或者 Hypervisor（一种针对虚拟机高度优化后的操作系统）。</p>
<p>虚拟机模型将底层硬件资源划分到虚拟机当中。每个虚拟机都是包含了虚拟 CPU、虚拟 RAM、虚拟磁盘等资源的一种软件结构。</p>
<p>因此，每个虚拟机都需要有自己的操作系统来声明、初始化并管理这些虚拟资源。</p>
<p>但是，操作系统本身是有其额外开销的。例如，每个操作系统都消耗一点 CPU、一点 RAM、一点存储空间等。</p>
<p>每个操作系统都需要独立的许可证，并且都需要打补丁升级，每个操作系统也都面临被攻击的风险。</p>
<p>通常将这种现象称作 OS Tax 或者 VM Tax，每个操作系统都占用一定的资源。</p>
<p>容器模型具有在宿主机操作系统中运行的单个内核。在一台主机上运行数十个甚至数百个容器都是可能的——容器共享一个操作系统/内核。</p>
<p>这意味着只有一个操作系统消耗 CPU、RAM 和存储资源，只有一个操作系统需要授权，只有一个操作系统需要升级和打补丁。同时，只有一个操作系统面临被攻击的风险。简言之，就是只有一份 OS 损耗。</p>
<p>在上述单台机器上只需要运行 4 个业务应用的场景中，也许问题尚不明显。但当需要运行成百上千应用的时候，就会引起质的变化。</p>
<p>另一个值得考虑的事情是启动时间。因为容器并不是完整的操作系统，所以其启动要远比虚拟机快。</p>
<p>切记，在容器内部并不需要内核，也就没有定位、解压以及初始化的过程——更不用提在内核启动过程中对硬件的遍历和初始化了。</p>
<p>这些在容器启动的过程中统统都不需要！唯一需要的是位于下层操作系统的共享内核是启动了的！最终结果就是，容器可以在 1s 内启动。唯一对容器启动时间有影响的就是容器内应用启动所花费的时间。</p>
<p>这就是容器模型要比虚拟机模型简洁并且高效的原因了。使用容器可以在更少的资源上运行更多的应用，启动更快，并且支付更少的授权和管理费用，同时面对未知攻击的风险也更小。</p>
<h1 id="docker数据卷数据挂载">docker数据卷（数据挂载）</h1>
<p>docker的镜像是由多个只读的文件系统叠加在一起形成的。当我们在我启动一个容器的时候，docker会加载这些只读层并在这些只读层的上面(栈顶)增加一个读写层。这时如果修改正在运行的容器中已有的文件，那么这个文件将会从只读层复制到读写层。该文件的只读版本还在，只是被上面读写层的该文件的副本隐藏。当删除docker,或者重新启动时，之前的更改将会消失。在Docker中，只读层及在顶部的读写层的组合被称为Union File System（联合文件系统）。<code>简单来说，没有数据卷的时候，删除容器=删除容器内所有数据。</code></p>
<p>为了很好的实现数据保存和数据共享，Docker提出了Volume这个概念，简单的说就是绕过默认的联合文件系统，而以正常的文件或者目录的形式存在于宿主机上。又被称作数据卷。是<code>软连接，数据只有一份，双向同步</code>。</p>
<p>好处就是，<code>比如把本机nginx配置和docker内配置相互挂载，以后修改本机nginx配置后</code>，再打开docker nginx就方便很多了</p>
<h3 id="使用数据卷">使用数据卷</h3>
<blockquote>
<p>方式一：使用命令挂载 -v</p>
</blockquote>
<pre><code class="language-bash">docker run -it -v 宿主机目录:容器内目录
</code></pre>
<p>可以在docker inspect中的monts属性查看挂载情况</p>
<blockquote>
<p>方式二： 使用--mount</p>
</blockquote>
<pre><code class="language-text">docker run --name xxxx -p 8888:8888 --mount   
type:volume,source=/src/xxx,target=/xxx /my:/docker -it imagename /bin/bash 
</code></pre>
<p>type选项，其可以是bind，volume，或 tmpfs。本主题讨论卷，因此类型始终是 volume</p>
<p>注意：使用-v参数时如果本地目录不存在Docker会自动为你创建一个文件夹。使用<code>--mount</code>参数时如果本地目录不存在，Docker会报错。Docker挂载主机目录的默认权限是读写，用户也可以通过增加readonly指定为只读。</p>
<ul>
<li>如果挂载一个空的数据卷到容器中的一个非空目录中，那么这个目录下的文件会被复制到数据卷中。(我的测试：使用 -v 参数并没有这个效果，需要使<code>--mount</code>参数，如果不符请指正)</li>
<li>如果挂载一个非空的数据卷到容器中的一个目录中，那么容器中的目录中会显示数据卷中的数据。如果原来容器中目录非空，那么这些原始数据会被隐藏掉。</li>
</ul>
<p>匿名挂载：docker volume ls命令后 是无序字符串的就是匿名挂载。</p>
<p>具名挂载：配置的时候 变成-v 名字:容器目录 之后本机挂载位置可以通过inspect命令查看  <code>推荐</code></p>
<blockquote>
<p>拓展：在-v 卷名（或者宿主机路径）:容器路径:rw(这个是权限 可以选ro[read only]或者rw[read＆write])</p>
<p>ro即是只能从容器外部改变（即容器内部不可写）</p>
</blockquote>
<hr>
<h1 id="docker网络">docker网络</h1>
<p>没有计网只是的 可以跳过本章节了</p>
<h3 id="docker0">docker0</h3>
<p>输入ip addr 查看网络状况时 很容易找到docker0的描述</p>
<pre><code class="language-bash">3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP 
    link/ether 02:42:ee:b5:9d:73 brd ff:ff:ff:ff:ff:ff
    inet 172.18.0.1/16 brd 172.18.255.255 scope global docker0
       valid_lft forever preferred_lft forever
</code></pre>
<p>docker0即是物理网卡直连NAT为docker生成的虚拟网卡</p>
<p>进入容器内部（我选择进入了centos8的容器） 用ip addr查看</p>
<pre><code class="language-bash">16: eth0@if17: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group 
#16: eth0@if17 是docker0分配的
default 
    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0
       valid_lft forever preferred_lft forever
#宿主机一定能ping通内部容器因为172.18.0.2可以发现他就是宿主机docker0给容器分配的网段，是同一网段内的
</code></pre>
<blockquote>
<p>原理</p>
</blockquote>
<p>docker0相当于docker生成的网卡</p>
<p>上面的情况使用的是桥接模式，使用的是evth-pair技术。当启动容器后，在宿主机内ip addr</p>
<p>就会发现出现了</p>
<pre><code class="language-shell">17: veth2844acd@if16: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP 
    link/ether f2:45:bc:90:59:53 brd ff:ff:ff:ff:ff:ff link-netnsid 0
</code></pre>
<p>一个容器 多<code>一对</code>网卡，即容器内的网卡对容器外的网卡。</p>
<p>evth-pair就是一对虚拟设备接口，一段连接协议。</p>
<p>所以evth-pair充当桥梁桥接宿主机和容器机，链接各种虚拟网络设备</p>
<p><mark>---容器间虽然相互隔离，但可以通过docker0转发，所以互相之间ping ip 可以ping通<code>docker0就相当于路由器</code>，docker0给容器分配默认的可用ip---</mark></p>
<p>这个特性有其缺陷，编写微服务的时候常常需要写ip地址调用，当docker遇到不可预测的问题宕机重启后，ip地址变了，写的服务层代码往往会失效。到后面会讲怎么解决。</p>
<h5 id="link">link</h5>
<p>启动容器时，设置 --link属性 后面+被接受容器名，即可实现两个容器间互通(当然 用)，比如</p>
<pre><code class="language-bash">docker run -it -P --name jayha_centos --link jayha_ubuntu7070 centos
</code></pre>
<p>输入docker network 命令 可查看docker的网络id号 通过id号即可用inspect查询目前网络各种情况。我们就会发现</p>
<p><code>link实现原理其实就是把link链接的容器，写死ip在本容器的host文件中，添加了一个映射。</code></p>
<p>所以，link已经是个被不看好的技术，也是个不实用的技术，了解即可。</p>
<hr>
<p><code>由此，我们为了拓展网络自由度，可以自己做网络。</code></p>
<h3 id="扩展docker网络">扩展docker网络</h3>
<p>💛docker网络模式有：bridge（默认），none（不配置网络），host（与宿主机共享网络），container（容器网络连通，局限极大，基本不用）</p>
<p>而拓展docker用的就是bridge</p>
<p>创建网络方式为：</p>
<pre><code class="language-bash">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet
#                     连接方式设置为桥接    设置子网                网关                网络名
</code></pre>
<p>之后在启动容器时， 设置--net属性时候， 即可用自己创建的网络，这样的话 直接ping容器名字都可以ping通了。</p>
<p>好处就是，<code>不同的集群使用不同的网络，可以保证集群的安全健康。</code></p>
<p>容器与不同的网络之间也是可以打通的 可以使用</p>
<pre><code class="language-bash">docker network connect [参数] [网络] [容器]
</code></pre>
<p>来打通</p>
<hr>
<h1 id="dockerfile">dockerFile</h1>
<p>即是<code>用来构建docker image</code>的构建文件或者可以说是命令脚本，相当于编写docker images的源代码。</p>
<figure data-type="image" tabindex="4"><img src="D:%5C%E5%9B%BE%E5%BA%8A%5CdockerFile%E7%9A%84%E6%8C%87%E4%BB%A4%E5%9C%A8%E5%B9%B2%E4%BB%80%E4%B9%88.png" alt="" loading="lazy"></figure>
<p><strong>FROM：指定基础镜像，必须为第一个命令</strong> ：docker hub上九成九都是从scratch开始的（了解即可 我们不用从这个开始写</p>
<pre><code>格式：
　　FROM &lt;image&gt;
　　FROM &lt;image&gt;:&lt;tag&gt;
　　FROM &lt;image&gt;@&lt;digest&gt;示例：　　FROM mysql:5.6注：　　tag或digest是可选的，如果不使用这两个值时，会使用latest版本的基础镜像
</code></pre>
<p><strong>MAINTAINER: 维护者信息</strong></p>
<pre><code>格式：
    MAINTAINER &lt;name&gt;
示例：
    MAINTAINER Jasper Xu
    MAINTAINER sorex@163.com
    MAINTAINER Jasper Xu &lt;sorex@163.com&gt;
</code></pre>
<p><strong>RUN：构建镜像时执行的命令</strong></p>
<pre><code>RUN用于在镜像容器中执行命令，其有以下两种命令执行方式：
shell执行
格式：
    RUN &lt;command&gt;
exec执行
格式：
    RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]
示例：
    RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]
    RUN apk update
    RUN [&quot;/etc/execfile&quot;, &quot;arg1&quot;, &quot;arg1&quot;]
注：　　RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定--no-cache参数，如：docker build --no-cache
</code></pre>
<p><strong>ADD：将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源，类似wget</strong></p>
<pre><code>格式：
    ADD &lt;src&gt;... &lt;dest&gt;
    ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;] 用于支持包含空格的路径
示例：
    ADD hom* /mydir/          # 添加所有以&quot;hom&quot;开头的文件
    ADD hom?.txt /mydir/      # ? 替代一个单字符,例如：&quot;home.txt&quot;
    ADD test relativeDir/     # 添加 &quot;test&quot; 到 `WORKDIR`/relativeDir/
    ADD test /absoluteDir/    # 添加 &quot;test&quot; 到 /absoluteDir/
</code></pre>
<p><strong>COPY：功能类似ADD，但是是不会自动解压文件，也不能访问网络资源</strong></p>
<p><strong>CMD：构建容器后调用，也就是在容器启动时才进行调用。</strong></p>
<pre><code>格式：
    CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (执行可执行文件，优先)
    CMD [&quot;param1&quot;,&quot;param2&quot;] (设置了ENTRYPOINT，则直接调用ENTRYPOINT添加参数)
    CMD command param1 param2 (执行shell内部命令)
示例：
    CMD echo &quot;This is a test.&quot; | wc -
    CMD [&quot;/usr/bin/wc&quot;,&quot;--help&quot;]注： 　　CMD不同于RUN，CMD用于指定在容器启动时所要执行的命令，而RUN用于指定镜像构建时所要执行的命令。
</code></pre>
<p><strong>ENTRYPOINT：配置容器，使其可执行化。配合CMD可省去&quot;application&quot;，只使用参数。</strong></p>
<pre><code>格式：
    ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (可执行文件, 优先)
    ENTRYPOINT command param1 param2 (shell内部命令)
示例：
    FROM ubuntu
    ENTRYPOINT [&quot;top&quot;, &quot;-b&quot;]
    CMD [&quot;-c&quot;]注：　　　ENTRYPOINT与CMD非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给ENTRYPOINT。Dockerfile中只允许有一个ENTRYPOINT命令，多指定时会覆盖前面的设置，而只执行最后的ENTRYPOINT指令。
</code></pre>
<p><strong>LABEL：用于为镜像添加元数据</strong></p>
<pre><code>格式：
    LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...
示例：
　　LABEL version=&quot;1.0&quot; description=&quot;这是一个Web服务器&quot; by=&quot;IT笔录&quot;
注：
　　使用LABEL指定元数据时，一条LABEL指定可以指定一或多条元数据，指定多条元数据时不同元数据之间通过空格分隔。推荐将所有的元数据通过一条LABEL指令指定，以免生成过多的中间镜像。
</code></pre>
<p><strong>ENV：设置环境变量</strong></p>
<pre><code>格式：
    ENV &lt;key&gt; &lt;value&gt;  #&lt;key&gt;之后的所有内容均会被视为其&lt;value&gt;的组成部分，因此，一次只能设置一个变量
    ENV &lt;key&gt;=&lt;value&gt; ...  #可以设置多个变量，每个变量为一个&quot;&lt;key&gt;=&lt;value&gt;&quot;的键值对，如果&lt;key&gt;中包含空格，可以使用\来进行转义，也可以通过&quot;&quot;来进行标示；另外，反斜线也可以用于续行
示例：
    ENV myName John Doe
    ENV myDog Rex The Dog
    ENV myCat=fluffy
</code></pre>
<p><strong>EXPOSE：指定于外界交互的端口</strong></p>
<pre><code>格式：
    EXPOSE &lt;port&gt; [&lt;port&gt;...]
示例：
    EXPOSE 80 443
    EXPOSE 8080    EXPOSE 11211/tcp 11211/udp注：　　EXPOSE并不会让容器的端口访问到主机。要使其可访问，需要在docker run运行容器时通过-p来发布这些端口，或通过-P参数来发布EXPOSE导出的所有端口
</code></pre>
<p><strong>VOLUME：用于指定持久化目录</strong></p>
<pre><code>格式：
    VOLUME [&quot;/path/to/dir&quot;]
示例：
    VOLUME [&quot;/data&quot;]
    VOLUME [&quot;/var/www&quot;, &quot;/var/log/apache2&quot;, &quot;/etc/apache2&quot;注：　　一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：
1 卷可以容器间共享和重用
2 容器并不一定要和其它容器共享卷
3 修改卷后会立即生效
4 对卷的修改不会对镜像产生影响
5 卷会一直存在，直到没有任何容器在使用它
</code></pre>
<p><strong>WORKDIR：工作目录，类似于cd命令</strong></p>
<pre><code>格式：
    WORKDIR /path/to/workdir
示例：
    WORKDIR /a  (这时工作目录为/a)
    WORKDIR b  (这时工作目录为/a/b)
    WORKDIR c  (这时工作目录为/a/b/c)注：　　通过WORKDIR设置工作目录后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT、ADD、COPY等命令都会在该目录下执行。在使用docker run运行容器时，可以通过-w参数覆盖构建时所设置的工作目录。
</code></pre>
<p>**USER:**<strong>指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。使用USER指定用户时，可以使用用户名、UID或GID，或是两者的组合。当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户</strong></p>
<pre><code class="language-bash">格式:
　　USER user
　　USER user:group
　　USER uid
　　USER uid:gid
　　USER user:gid
　　USER uid:group

 示例：
    　　USER www
</code></pre>
<p>注：</p>
<p>使用USER指定用户后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT都将使用该用户。镜像构建完成后，通过<code>docker run</code>运行容器时，可以通过-u参数来覆盖所指定的用户。</p>
<p><strong>ARG：用于指定传递给构建运行时的变量</strong></p>
<pre><code>格式：
    ARG &lt;name&gt;[=&lt;default value&gt;]
示例：
    ARG site
    ARG build_user=www
</code></pre>
<p><strong>ONBUILD：用于设置镜像触发器</strong></p>
<pre><code>格式：　　ONBUILD [INSTRUCTION]
示例：
　　ONBUILD ADD . /app/src
　　ONBUILD RUN /usr/local/bin/python-build --dir /app/src
注：　　当所构建的镜像被用做其它镜像的基础镜像，该镜像中的触发器将会被钥触发
</code></pre>
<p><strong>以下是一个小例子：</strong></p>
<pre><code># This my first nginx Dockerfile
# Version 1.0

# Base images 基础镜像
FROM centos

#MAINTAINER 维护者信息
MAINTAINER tianfeiyu 

#ENV 设置环境变量
ENV PATH /usr/local/nginx/sbin:$PATH

#ADD  文件放在当前目录下，拷过去会自动解压
ADD nginx-1.8.0.tar.gz /usr/local/  
ADD epel-release-latest-7.noarch.rpm /usr/local/  

#RUN 执行以下命令 
RUN rpm -ivh /usr/local/epel-release-latest-7.noarch.rpm
RUN yum install -y wget lftp gcc gcc-c++ make openssl-devel pcre-devel pcre &amp;&amp; yum clean all
RUN useradd -s /sbin/nologin -M www

#WORKDIR 相当于cd
WORKDIR /usr/local/nginx-1.8.0 

RUN ./configure --prefix=/usr/local/nginx --user=www --group=www --with-http_ssl_module --with-pcre &amp;&amp; make &amp;&amp; make install

RUN echo &quot;daemon off;&quot; &gt;&gt; /etc/nginx.conf

#EXPOSE 映射端口
EXPOSE 80

#CMD 运行以下命令
CMD [&quot;nginx&quot;]
</code></pre>
<p><strong><code>可以！推送到阿里云的镜像仓库！</code></strong></p>
<p><s>吐槽：极其类似github 我怀疑不管docker官方还是阿里云代码都借鉴了很多linus写的东西，至少是思想</s></p>
<figure data-type="image" tabindex="5"><img src="https://jayhablog.vercel.app/post-images/1617773530086.png" alt="Jayha的，别乱用" loading="lazy"></figure>
<hr>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://jayhablog.vercel.app/geng-you-ya-de-xie-jie-kou-zhuan/">
                  <h3 class="post-title">
                    更优雅的写接口（转）
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/aos@2.3.4/dist/aos.min.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
