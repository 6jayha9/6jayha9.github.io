<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>我理解的M-WAY树＆B树＆B+树 | Jayha小罗的秘密基地</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.0/css/all.min.css">
<link rel="shortcut icon" href="https://jayhablog.vercel.app/favicon.ico?v=1622639253302">
<link rel="stylesheet" href="https://jayhablog.vercel.app/styles/main.css">





<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aos@2.3.4/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="来自于https://www.bilibili.com/video/BV1UC4y1p7zm?from=search&amp;seid=10138161092795701955 的归纳整理 感谢这位印度老师的课程。
M-way树、B树、B+..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://jayhablog.vercel.app">
        <img src="https://jayhablog.vercel.app/images/avatar.png?v=1622639253302" class="site-logo">
        <h1 class="site-title">Jayha小罗的秘密基地</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="https://jayhablog.vercel.app/guan-yu-ben-zhan" class="site-nav">
            关于本站呢~
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      欢迎来到Jayha小罗的Blog嘻嘻嘻：）
    </div>
    <div class="site-footer">
      <a href="https://gitee.com/jayha" target="_blank">Jayha的Gitee首页</a> | <a class="rss" href="https://jayhablog.vercel.app/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">我理解的M-WAY树＆B树＆B+树</h2>
            <div class="post-date">2021-06-02</div>
            
              <div class="feature-container" style="background-image: url('https://jayhablog.vercel.app/post-images/wo-li-jie-de-m-way-shu-andb-shu-andbshu.jpg')">
              </div>
            
            <div class="post-content" v-pre>
              <p>来自于https://www.bilibili.com/video/BV1UC4y1p7zm?from=search&amp;seid=10138161092795701955 的归纳整理 感谢这位印度老师的课程。</p>
<p>M-way树、B树、B+树其实是一种数据结构的不同变形，最终形态的B+树往往用于数据库索引的存储。</p>
<h3 id="为什么要建索引">为什么要建索引</h3>
<p>操作系统的一些小常识必须先了解：磁盘由轨道和扇区切分成一个个“块”（blocks，通常大小为512字节，在不同的磁盘里大小也不一样），数据在磁盘内不能直接操作，所以DBMS必须经过ram读入并处理才能写回磁盘。读取多个block，这对磁盘I／O是一种消耗（因为每读取一个block都会消耗磁盘I/O,磁盘每次读取都是以block为单位的），所以为了降低磁盘损耗，我们把关键字和关键字对应行的地址建立成一个“索引”，由于索引大小远远小于行的大小，一个block可以存的索引数比行数多，遍历索引就比遍历行快，I/O损耗也小。</p>
<p>以聚簇索引为例，索引由一个建索引所依据的字段（通常是主键）和指向其所在行的指针组成（也需要占据一定的块）这样就可以只遍历索引表所在的block，遍历的block数量就会大大减小。</p>
<h3 id="m-way树">M-way树</h3>
<p>然而当库表数据大到一定程度的时候，搜索效率还是会下降，我们就需要建一个稀疏index表，选举之前的index表的部分节点到稀疏index表中，并将选举出来的点作为分割点，将原先的表进行分割，稀疏的index表中，索引和指向之前的表分裂出来的子表的指针交错，同样的思想，可以不只建一层稀疏索引，可以建多层，取决于数据库数据量大小，但稀疏index表最少都要有两行数据，因为一行没有意义。</p>
<p>大概长这样</p>
<figure data-type="image" tabindex="1"><img src="https://cdnir.com/i/2021/06/02/xflnds.jpg" alt="" loading="lazy"></figure>
<p>key就是关键字。</p>
<p>把这个东西横过来，就长得很像树啦，我们称之为M-way树（其实真正的M-way树除了key和指向之前的表分裂出来的子表的指针外 还有一个recordpoint即指向数据库中真正数据地址的指针，也就是key和recordpoint形成了索引）。</p>
<figure data-type="image" tabindex="2"><img src="https://cdnir.com/i/2021/06/02/xizh5j.jpg" alt="" loading="lazy"></figure>
<p>这里能读懂也就基本能了解B树的思想了，因为B树就是M-way树加了限制条件的一种数据结构</p>
<h3 id="b树">B树</h3>
<p>M-way树最大的问题是，不能自维护插入和删除数据的时候，所以希望它进行自我管理，这就是B树的实现目的。</p>
<figure data-type="image" tabindex="3"><img src="https://cdnir.com/i/2021/06/02/xca4er.png" alt="" loading="lazy"></figure>
<p>通常我们说m阶的B树（阶即是一个结点最多可以拥有多少个子节点），它必须满足如下条件：</p>
<ul>
<li>每个节点最多只有m个子节点。</li>
<li>每个非叶子节点（除了根）具有至少⌈ m/2⌉子节点。</li>
<li>如果根不是叶节点，则根至少有两个子节点。</li>
<li>具有<em>k</em>个子节点的非叶节点包含<em>k</em> -1个键。（k为关键字个数）</li>
<li>所有叶子都出现在同一水平，没有任何信息（高度一致）。</li>
</ul>
<p>对于B树的插入删除操作，我的水平讲起来还是有点头疼，搬运一下https://www.cnblogs.com/lianzhilei/p/11250589.html 这位大佬的资料 感谢大佬，之后有时间我会自己重写一遍</p>
<p><strong>插入</strong></p>
<p>针对m阶高度h的B树，插入一个元素时，首先在B树中是否存在，如果不存在，即在叶子结点处结束，然后在叶子结点中插入该新的元素。</p>
<ul>
<li>若该节点元素个数小于m-1，直接插入；</li>
<li>若该节点元素个数等于m-1，引起节点分裂；以该节点中间元素为分界，取中间元素（偶数个数，中间两个随机选取）插入到父节点中；</li>
<li>重复上面动作，直到所有节点符合B树的规则；最坏的情况一直分裂到根节点，生成新的根节点，高度增加1；</li>
</ul>
<p>上面三段话为插入动作的核心，接下来以5阶B树为例，详细讲解插入的动作；</p>
<p>5阶B树关键点:</p>
<ul>
<li>2&lt;=根节点子节点个数&lt;=5</li>
<li>3&lt;=内节点子节点个数&lt;=5</li>
<li>1&lt;=根节点元素个数&lt;=4</li>
<li>2&lt;=非根节点元素个数&lt;=4</li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/997909/201907/997909-20190727135621105-1688663582.png" alt="img" loading="lazy">   插入8     <img src="https://img2018.cnblogs.com/blog/997909/201907/997909-20190727150240628-562673561.png" alt="img" loading="lazy"></p>
<p>图（1）插入元素【8】后变为图（2），此时根节点元素个数为5，不符合 1&lt;=根节点元素个数&lt;=4，进行分裂（真实情况是先分裂，然后插入元素，这里是为了直观而先插入元素，下面的操作都一样，不再赘述），取节点中间元素【7】，加入到父节点，左右分裂为2个节点，如图（3）</p>
<figure data-type="image" tabindex="4"><img src="https://img2018.cnblogs.com/blog/997909/201907/997909-20190727150127189-82041957.png" alt="img" loading="lazy"></figure>
<p>接着插入元素【5】，【11】，【17】时，不需要任何分裂操作，如图（4）</p>
<figure data-type="image" tabindex="5"><img src="https://img2018.cnblogs.com/blog/997909/201907/997909-20190727150529778-12220622.png" alt="img" loading="lazy"></figure>
<p>插入元素【13】</p>
<figure data-type="image" tabindex="6"><img src="https://img2018.cnblogs.com/blog/997909/201907/997909-20190727150325549-653814900.png" alt="img" loading="lazy"></figure>
<p>节点元素超出最大数量，进行分裂，提取中间元素【13】，插入到父节点当中，如图（6）</p>
<figure data-type="image" tabindex="7"><img src="https://img2018.cnblogs.com/blog/997909/201907/997909-20190727150403812-1196185160.png" alt="img" loading="lazy"></figure>
<p>接着插入元素【6】，【12】，【20】，【23】时，不需要任何分裂操作，如图（7）</p>
<figure data-type="image" tabindex="8"><img src="https://img2018.cnblogs.com/blog/997909/201907/997909-20190727151202374-95300359.png" alt="img" loading="lazy"></figure>
<p>插入【26】时，最右的叶子结点空间满了，需要进行分裂操作，中间元素【20】上移到父节点中，注意通过上移中间元素，树最终还是保持平衡，分裂结果的结点存在2个关键字元素。</p>
<figure data-type="image" tabindex="9"><img src="https://img2018.cnblogs.com/blog/997909/201907/997909-20190727152815688-1828133575.png" alt="img" loading="lazy"></figure>
<p>插入【4】时，导致最左边的叶子结点被分裂，【4】恰好也是中间元素，上移到父节点中，然后元素【16】,【18】,【24】,【25】陆续插入不需要任何分裂操作</p>
<figure data-type="image" tabindex="10"><img src="https://img2018.cnblogs.com/blog/997909/201907/997909-20190727153234424-288986187.png" alt="img" loading="lazy"></figure>
<p>最后，当插入【19】时，含有【14】,【16】,【17】,【18】的结点需要分裂，把中间元素【17】上移到父节点中，但是情况来了，父节点中空间已经满了，所以也要进行分裂，将父节点中的中间元素【13】上移到新形成的根结点中，这样具体插入操作的完成。</p>
<figure data-type="image" tabindex="11"><img src="https://img2018.cnblogs.com/blog/997909/201907/997909-20190727154112560-585266052.png" alt="img" loading="lazy"></figure>
<p><strong>删除</strong></p>
<p>首先查找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除；删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之后的情况；如果没有，直接删除。</p>
<ul>
<li>某结点中元素数目小于（m/2）-1,(m/2)向上取整，则需要看其某相邻兄弟结点是否丰满；</li>
<li>如果丰满（结点中元素个数大于(m/2)-1），则向父节点借一个元素来满足条件；</li>
<li>如果其相邻兄弟都不丰满，即其结点数目等于(m/2)-1，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点；</li>
</ul>
<p>接下来还以5阶B树为例，详细讲解删除的动作；</p>
<ul>
<li>关键要领，元素个数小于 2（m/2 -1）就合并，大于4（m-1）就分裂</li>
</ul>
<p>如图依次删除依次删除【8】,【20】,【18】,【5】</p>
<figure data-type="image" tabindex="12"><img src="https://img2018.cnblogs.com/blog/997909/201907/997909-20190727160351637-1629033369.png" alt="img" loading="lazy"></figure>
<p>首先删除元素【8】，当然首先查找【8】，【8】在一个叶子结点中，删除后该叶子结点元素个数为2，符合B树规则，操作很简单，咱们只需要移动【11】至原来【8】的位置，移动【12】至【11】的位置（也就是结点中删除元素后面的元素向前移动）</p>
<figure data-type="image" tabindex="13"><img src="https://img2018.cnblogs.com/blog/997909/201907/997909-20190727160902710-1900336278.png" alt="img" loading="lazy"></figure>
<p>下一步，删除【20】,因为【20】没有在叶子结点中，而是在中间结点中找到，咱们发现他的继承者【23】(字母升序的下个元素)，将【23】上移到【20】的位置，然后将孩子结点中的【23】进行删除，这里恰好删除后，该孩子结点中元素个数大于2，无需进行合并操作。</p>
<figure data-type="image" tabindex="14"><img src="https://img2018.cnblogs.com/blog/997909/201907/997909-20190727161905571-1441211802.png" alt="img" loading="lazy"></figure>
<p>下一步删除【18】，【18】在叶子结点中,但是该结点中元素数目为2，删除导致只有1个元素，已经小于最小元素数目2,而由前面我们已经知道：如果其某个相邻兄弟结点中比较丰满（元素个数大于ceil(5/2)-1=2），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中，在这个实例中，右相邻兄弟结点中比较丰满（3个元素大于2），所以先向父节点借一个元素【23】下移到该叶子结点中，代替原来【19】的位置，【19】前移；然【24】在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除【24】，后面元素前移。</p>
<figure data-type="image" tabindex="15"><img src="https://img2018.cnblogs.com/blog/997909/201907/997909-20190727162837714-1263711630.png" alt="img" loading="lazy"></figure>
<p>最后一步删除【5】， 删除后会导致很多问题，因为【5】所在的结点数目刚好达标，刚好满足最小元素个数（ceil(5/2)-1=2）,而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件，所以需要该节点与某相邻兄弟结点进行合并操作；首先移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中，然后将这两个结点进行合并成一个结点。所以在该实例中，咱们首先将父节点中的元素【4】下移到已经删除【5】而只有【6】的结点中，然后将含有【4】和【6】的结点和含有【1】,【3】的相邻兄弟结点进行合并成一个结点。<br>
<img src="https://img2018.cnblogs.com/blog/997909/201907/997909-20190727163249830-1144020179.png" alt="img" loading="lazy"></p>
<p>也许你认为这样删除操作已经结束了，其实不然，在看看上图，对于这种特殊情况，你立即会发现父节点只包含一个元素【7】，没达标（因为非根节点包括叶子结点的元素K必须满足于2=&lt;K&lt;=4，而此处的K=1），这是不能够接受的。如果这个问题结点的相邻兄弟比较丰满，则可以向父结点借一个元素。而此时兄弟节点元素刚好为2，刚刚满足，只能进行合并，而根结点中的唯一元素【13】下移到子结点，这样，树的高度减少一层。<br>
<img src="https://img2018.cnblogs.com/blog/997909/201907/997909-20190727163912012-1560407429.png" alt="img" loading="lazy"></p>
<p>磁盘IO是非常高昂的操作，所以操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存cache中（因为读取相邻数据的概率较高），称之为局部预读性，所以访问一个数据，相邻数据也会很快访问到，若我们将读取一个节点视为一个IO的话，那么B树读取IO的次数和其时间复杂度都为对数级，大大减小I/O次数，搜索效率大大提升。</p>
<h3 id="b树-2">B+树</h3>
<p>B+树是针对B树进行了优化。</p>
<p>具体的优化为，首先是叶子节点存储所有的关键字和关键字对应行的地址，其上的所有非叶子节点仅保存指向叶子节点的索引（仅含有其子树根结点中最大（或最小）关键字），并且所有叶子节点因为在同一高度，B+树也可以轻松的将其串联起来，形成一个链表。</p>
<p>那么这些优化有什么好处呢？首先非叶子节点全部只存关键字，所有非叶子节点的大小就更小了，一个block就可以容纳更多的非叶子节点，遍历速度就更快了，I/O消耗也就更小了。</p>
<p>其次是由于局部预读性，本来B树预读的数据，其附近的关键字和和其绝对值相差往往较大（一个节点中两个相邻的key和recordpoint的绝对值是他们之间的指针指向的子树所有值的总和），指向子节点的指针又没有预读的需要，在范围查找中，二次搜索命中预读的概率较低，而B+树读取的是叶子节点，叶子节点无指向子节点的索引，相邻关键字的绝对值又比较小，预读命中概率就大了。</p>
<p>其次是B+树查询更为稳定，因为一定要查询到叶子节点才能得到地址。</p>
<p>最后是所有叶子节点使用链表方式进行串联，查找到叶子节点后可以直接对叶子节点进行遍历，便于范围查找。</p>
<figure data-type="image" tabindex="16"><img src="https://img2018.cnblogs.com/blog/997909/201907/997909-20190728114240297-169990922.png" alt="img" loading="lazy"></figure>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://jayhablog.vercel.app/springsecurity-gai-xie-guo-lu-lian-shi-xian-xiao-cheng-xu-deng-lu/">
                  <h3 class="post-title">
                    springsecurity改写过滤链实现小程序登录
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/aos@2.3.4/dist/aos.min.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
