<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jayhablog.vercel.app</id>
    <title>Jayha小罗的秘密基地</title>
    <updated>2020-09-24T10:27:37.544Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jayhablog.vercel.app"/>
    <link rel="self" href="https://jayhablog.vercel.app/atom.xml"/>
    <subtitle>欢迎来到Jayha小罗的Blog嘻嘻嘻：）</subtitle>
    <logo>https://jayhablog.vercel.app/images/avatar.png</logo>
    <icon>https://jayhablog.vercel.app/favicon.ico</icon>
    <rights>All rights reserved 2020, Jayha小罗的秘密基地</rights>
    <entry>
        <title type="html"><![CDATA[spring-security安全认证框架Part1（非OAuth2部分）]]></title>
        <id>https://jayhablog.vercel.app/spring-security-an-quan-ren-zheng-kuang-jia-1/</id>
        <link href="https://jayhablog.vercel.app/spring-security-an-quan-ren-zheng-kuang-jia-1/">
        </link>
        <updated>2020-09-13T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<hr>
<p>spring-security是通过servlet的filter链方式实现的一种认证，授权<br>
<img src="https://jayhablog.vercel.app/post-images/1599995513270.png" alt="" loading="lazy"><br>
快速入门（在内存中使用）；</p>
<p>在内存中的使用非常简单</p>
<p>阅读代码即可</p>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class securityConfig extends WebSecurityConfigurerAdapter {

    @Bean
    public PasswordEncoder passwordEncoder() {
        // BCryptPasswordEncoder：Spring Security 提供的加密工具，可快速实现加密加盐
        return new BCryptPasswordEncoder();
    }
    @Bean
    public UserDetailsService userDetailsService(){
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        return  manager;
    }
    /**
     * 该方法是授权相关方法
     * @param http
     * @throws Exception
     */
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        //首页所有人可以访问&quot;/&quot;
        http.authorizeRequests()
                .antMatchers(&quot;/&quot;).permitAll()
                .antMatchers(&quot;/index.html&quot;).permitAll()
                .antMatchers(&quot;/index&quot;).permitAll()
                .antMatchers(&quot;/home&quot;).permitAll()
                .antMatchers(&quot;/welcome&quot;).permitAll()
                .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)
                .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)
                .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;)
        .and().formLogin()//开启自定义页面
                .loginPage(&quot;/userlogin&quot;).loginProcessingUrl(&quot;/welcome&quot;).usernameParameter(&quot;username&quot;).passwordParameter(&quot;password&quot;).
                failureHandler((req, resp, exception) -&gt; {
                    resp.setContentType(&quot;application/json;charset=utf-8&quot;);
                            PrintWriter out = resp.getWriter();
                            out.write(&quot;登录失败...&quot;);
                    out.flush();
                })
                .permitAll()
                .and()
                .httpBasic()
                .and()
                // 关闭CSRF跨域
                .csrf().disable();
        ;
        //没有权限跳到登录页
        /*http.formLogin();*/
        //关闭csrf功能
        //http.csrf().disable();
        //开启注销 成功跳到“/”
        http.logout().logoutSuccessUrl(&quot;/&quot;);
    }

    /**
     * 该方法是认证相关方法
     * @param auth
     * @throws Exception
     */
    /*@Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        //从内存中读
        //使用BCrypt加密

        auth.inMemoryAuthentication().passwordEncoder(passwordEncoder())
                .withUser(&quot;jayha&quot;).password(passwordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip3&quot;,&quot;vip2&quot;)
                .and()
                .withUser(&quot;nanha&quot;).password(passwordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;);

    }*/

    @Override
    public void configure(WebSecurity web) throws Exception {
        // 设置拦截忽略url - 会直接过滤该url - 将不会经过Spring Security过滤器链
        web.ignoring().antMatchers(&quot;/getUserInfo&quot;);
        // 设置拦截忽略文件夹，可以对静态资源放行
        web.ignoring().antMatchers(&quot;/css/**&quot;, &quot;/js/**&quot;);

    }
}
</code></pre>
<hr>
<hr>
<p>BCryptPasswordEncoder</p>
<p>是spring提供的一种特殊加密方式，建议数据库以次类方式存储，有静态方法hashpw(实际密码，盐分值[也可由Bcrypt自动生成])</p>
<pre><code class="language-java">void testBcrypto(){
        String s1 = BCrypt.hashpw(&quot;sir159357&quot;, BCrypt.gensalt());
        String s2 = BCrypt.hashpw(&quot;sir159357&quot;, BCrypt.gensalt());

        System.out.println(s1);
        System.out.println(s2);
    }
</code></pre>
<p>结果</p>
<pre><code class="language-tex">s1:$2a$10$WH2U/RLezICmMu8cAN2kQ.vWb46UOEtYbHgMeri8bc4JHGtKVGSKy

s2:$2a$10$aLTNf4pFC3OwyEM/r.9aeepuid9efVaLlvdqpNEDO01vPX.17kc0O
</code></pre>
<p>所以配置一个名为passwordEncoder的bean 该bean返回的值 就是security的编码方式</p>
<pre><code class="language-java">@Bean
    public PasswordEncoder passwordEncoder() {
        // BCryptPasswordEncoder：Spring Security 提供的加密工具，可快速实现加密加盐
        return new BCryptPasswordEncoder();
    }
</code></pre>
<p>接下来 我们就可以从内存过渡到数据库了</p>
<p>回到springsecurity流程图 我们可以发现认证是由一个叫做UserDetailsService的接口进行实现的。我们可以实现这个接口并把ta加入到IOC容器中</p>
<pre><code class="language-java">@Service
public class userdetailService implements UserDetailsService {

    @Autowired
    ItestuserDAO itestuserDAO;

    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
        testuser one = itestuserDAO.findOneByAccount(s);
        if(one == null){
            return null;//不用自己抛出异常 返回NULL spring=security会自动整理
        }else{
            UserDetails details = User.withUsername(one.getAccount()).password(one.getPassword()).authorities(&quot;vip1&quot;).build();//withusername方法即把username加入 password同理，authorities则是将用户进行授权操作
            return details;
        }
    }
}
</code></pre>
<p>注意的是这里给用户授权的是auth 而在SecurityConfig里面是授权的role 二者是不同授权理念的具体实现，现在一般是role（角色）包含auth（权限）这种操作  要注意更改</p>
<p><s>俺最初没理解好这两个东西的概念在这疯狂踩坑</s></p>
<pre><code class="language-java">@Override
    protected void configure(HttpSecurity http) throws Exception {
        //首页所有人可以访问&quot;/&quot;
        http.authorizeRequests()
                .antMatchers(&quot;/&quot;).permitAll()
                .antMatchers(&quot;/index.html&quot;).permitAll()
                .antMatchers(&quot;/index&quot;).permitAll()
                .antMatchers(&quot;/home&quot;).permitAll()
                .antMatchers(&quot;/welcome&quot;).permitAll()
                .antMatchers(&quot;/level1/**&quot;).hasAuthority(&quot;vip1&quot;)
                .antMatchers(&quot;/level2/**&quot;).hasAuthority(&quot;vip2&quot;)
                .antMatchers(&quot;/level3/**&quot;).hasAuthority(&quot;vip3&quot;)
                .and()
                .formLogin()//开启自定义页面
                .loginPage(&quot;/userlogin&quot;)
                .loginProcessingUrl(&quot;/welcome&quot;)
                .usernameParameter(&quot;username&quot;)
                .passwordParameter(&quot;password&quot;)

                .failureHandler((req, resp, exception) -&gt; {
                    resp.setContentType(&quot;application/json;charset=utf-8&quot;);
                            PrintWriter out = resp.getWriter();
                            out.write(&quot;登录失败...&quot;);
                    out.flush();
                }).permitAll()
                .and()
                .httpBasic()
                .and()
                // 关闭CSRF跨域
                .csrf().disable().cors();
        ;
        http.logout().logoutSuccessUrl(&quot;/&quot;);
    }
</code></pre>
<h5 id="用户登录后获取用户信息">用户登录后获取用户信息</h5>
<p>可以使用</p>
<pre><code class="language-java">Authentication authentication =SecurityContextHolder.getContext().getAuthentication();
        Object principal = authentication.getPrincipal();
</code></pre>
<p>principal就是UserDetail对象 可以强转后使用它的各种方法 比如获取姓名：</p>
<pre><code class="language-java"> @GetMapping(&quot;/getName&quot;)
    public String getUserAccount(){
        String account= null;
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        Object principal = authentication.getPrincipal();
        if(principal == null){
            account = &quot;匿名&quot;;
        }
        if(principal instanceof UserDetails){
            UserDetails u = (UserDetails)principal;
            account = u.getUsername();
        }
        return account;
    }
</code></pre>
<p>数据库的建立 除了用户类外 还要有角色表 与用户表是多对多关系 还要有权限表 和角色表也是多对多关系由于这个sql比较复杂 建议用mybatis</p>
<p>由于我们之后使用token来保持会话，所以 我们可以将session保持会话方式禁用</p>
<p><s>建议在学了token之后再关</s></p>
<pre><code class="language-java">protected void configure(HttpSecurity http) throws Exception {http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);}
</code></pre>
<hr>
<h4 id="方法授权">方法授权</h4>
<p>在配置类上（加了configuration注解的类）使用</p>
<pre><code class="language-java">@EnableGlobalMethodSecurity(securedEnabled = true )
</code></pre>
<p>开启方法授权 secured注解API支持</p>
<pre><code class="language-java">@Secured(&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;)//允许匿名访问的方法（即任何人都可以访问）
@Secured(&quot;ROLE_xx&quot;)//只有xx角色的可以访问

</code></pre>
<p>但不建议使用这个</p>
<p>建议使用prepost注解</p>
<pre><code class="language-java">@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)
</code></pre>
<pre><code class="language-java">@PreAuthorize(&quot;isAnonymous()&quot;) 匿名可以访问
@PreAuthorize(&quot;hasAuthority('vip1','vip2')&quot;)有vip1和vip2的可以访问
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[springboot集成定时，异步，邮件任务]]></title>
        <id>https://jayhablog.vercel.app/springboot-ji-cheng-ding-shi-yi-bu-you-jian-ren-wu/</id>
        <link href="https://jayhablog.vercel.app/springboot-ji-cheng-ding-shi-yi-bu-you-jian-ren-wu/">
        </link>
        <updated>2020-09-11T06:35:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="异步">异步</h2>
<hr>
<p>springboot主类下用@EnableAsync 开启异步</p>
<p>在需要用异步的方法上使用@Async注解，该任务会自动进入一个新进程，自动异步</p>
<h2 id="邮件">邮件</h2>
<hr>
<p>jar</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-mail --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;
&lt;/dependency&gt;

</code></pre>
<p>yaml配置信息</p>
<pre><code class="language-yaml">spring:
   mail:
     username: your_mail@xx.com
     password: your_password
     host: smtp.163.com  #example
     protocol: smtps   #example
</code></pre>
<p>springboot自动装JavaMailSenderImpl的实体类</p>
<pre><code class="language-java">//源码
@Bean
    JavaMailSenderImpl mailSender(Session session) {
        JavaMailSenderImpl sender = new JavaMailSenderImpl();
        sender.setDefaultEncoding(this.properties.getDefaultEncoding().name());
        sender.setSession(session);
        return sender;
    }
</code></pre>
<p>按照配置文件的属性进行创建，可以直接注入</p>
<pre><code class="language-java"> @Autowired
    private JavaMailSenderImpl mailSender;
</code></pre>
<p>之后直接用mailsender所提供的各种send进行发送就行 示例：</p>
<pre><code class="language-java">@Test
    void contextLoads()  {
        SimpleMailMessage mailMessage = new SimpleMailMessage();
        mailMessage.setSubject(&quot;早上好&quot;);
        mailMessage.setText(&quot;goodMoring&quot;);
        mailMessage.setTo(&quot;send_mail@qq.com&quot;);
        mailMessage.setFrom(&quot;your_mail@163.com&quot;);
        mailSender.send(mailMessage);
    }
</code></pre>
<p>若要发送复杂邮件 则可以取消simpleMailMessage类 用</p>
<pre><code class="language-java">MimeMessage mimeMessage = mailSender.createMimeMessage();
</code></pre>
<p>复杂类对象</p>
<pre><code class="language-java">        MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);

        helper.setSubject(&quot;早上好&quot;);
        helper.setText(&quot;&lt;a herf='www.baidu.com' &gt;今天 7:30来开会&lt;/a&gt;&quot;,true);

        //发送附件
        helper.addAttachment(&quot;1.jpg&quot;,new File(&quot;C:\\Users\\19029\\Desktop\\杂七杂八~\\1.jpg&quot;));

        helper.setTo(&quot;1902980268@qq.com&quot;);
        helper.setFrom(&quot;15999971548@163.com&quot;);
        mailSender.send(mimeMessage);
</code></pre>
<h2 id="定时">定时</h2>
<hr>
<p>项目开发中经常需要执行一些定时任务，比如需要在每天凌晨的时候，分析一次前一天的日志信息，Spring为我们提供了异步执行任务调度的方式，提供了两个接口。</p>
<ul>
<li>TaskExecutor接口</li>
<li>TaskScheduler接口</li>
</ul>
<p>两个注解：</p>
<ul>
<li>@EnableScheduling// 主main方法上 表示开启定时任务</li>
<li>@Scheduled//写cron表达式 表示什么时候</li>
</ul>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5C19029%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200911141657793.png" alt="image-20200911141657793" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[swagger初步实践]]></title>
        <id>https://jayhablog.vercel.app/swagger-chu-bu-shi-jian/</id>
        <link href="https://jayhablog.vercel.app/swagger-chu-bu-shi-jian/">
        </link>
        <updated>2020-09-10T08:04:11.000Z</updated>
        <content type="html"><![CDATA[<h3 id="swagger">swagger</h3>
<hr>
<p>swagger jar</p>
<pre><code class="language-xml">&lt;!--swagger--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
            &lt;version&gt;2.9.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--http://localhost:8080/swagger-ui.html--&gt;
        &lt;!--&lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
            &lt;version&gt;2.9.2&lt;/version&gt;
        &lt;/dependency&gt;--&gt;
        &lt;!--http://localhost:8080/document.html--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.zyplayer&lt;/groupId&gt;
            &lt;artifactId&gt;swagger-mg-ui&lt;/artifactId&gt;
            &lt;version&gt;1.0.6&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p><em>swagger的springboot内类配置</em></p>
<pre><code class="language-java">package cn.gdoujayha.springbootApplication.config;

import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.core.env.Profiles;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

import java.util.ArrayList;
import java.util.Properties;


@Configuration
@EnableSwagger2
public class SwaggerConfig {

    /**
     * 联系方式（作者名字，联系url，email）
     */
    private static final Contact CONTACT = new Contact(&quot;jayha&quot;,&quot;https://jayhablog.vercel.app&quot;,&quot;1902980268@qq.com&quot;) ;

    /*
        配置swagger的docket bean实例
         */
    @Bean
    /*@ConditionalOnProperty(prefix = &quot;profiles&quot;,havingValue = &quot;dev&quot;)*/
    public Docket docket(Environment environment){


        Profiles profiles = Profiles.of(&quot;dev&quot;,&quot;test&quot;);
        boolean flag = environment.acceptsProfiles(profiles);//“仅在dev和test环境下生效”


       return  new Docket(DocumentationType.SWAGGER_2)
                .groupName(&quot;jayha&quot;)//设置分组名 可以设置多个分组（多人协同的时候，可以一人一个或多个组）
                .enable(flag)
                .apiInfo(apiInfo())
                .select()
                /**
                 * apis：配置所需要扫描的地方
                 * requestHandlerSelectors有方式
                 * .basePackage配置扫描包
                 * .any扫描所有地方
                 * .none全不扫描
                 * .withClassAnnotation()只扫描类上有加了传入注解class的的那个注解的类（传入注解的class）
                 */
                .apis(RequestHandlerSelectors.basePackage(&quot;cn.gdoujayha.springbootApplication.controller&quot;))//配置扫描包
                /**
                 * paths配置过滤的路径
                 * 使用pathselector下的东西
                 * 下有：
                 * any全部
                 * none全否
                 * regex：正则
                 * ant（一般用这个）路径
                 */
                //.paths(PathSelectors.ant(&quot;/springbootApplication/controller/reginController/**&quot;))
                .build()
                ;
    }

    /**
     * apiinfo的配置
     * @return
     */
    private ApiInfo apiInfo(){
        return new ApiInfo(&quot;Jayha‘文档&quot;,
                &quot;关于''项目的swagger文档&quot;,
                &quot;0.1&quot;,
                &quot;urn:tos&quot;,
                CONTACT,
                &quot;Apache 2.0&quot;,
                &quot;http://www.apache.org/licenses/LICENSE-2.0&quot;,
                new ArrayList());
    }
}

</code></pre>
<blockquote>
<h3 id="常用注解">常用注解</h3>
</blockquote>
<p>Swagger的所有注解定义在io.swagger.annotations包下</p>
<p>下面列一些经常用到的，未列举出来的可以另行查阅说明：</p>
<table>
<thead>
<tr>
<th>Swagger注解</th>
<th style="text-align:center">简单说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Api(tags = &quot;xxx模块说明&quot;)</td>
<td style="text-align:center">作用在模块类上</td>
</tr>
<tr>
<td>@ApiOperation(&quot;xxx接口说明&quot;)</td>
<td style="text-align:center">作用在接口方法上</td>
</tr>
<tr>
<td>@ApiModel(&quot;xxxPOJO说明&quot;)</td>
<td style="text-align:center">作用在模型类上：如VO、BO</td>
</tr>
<tr>
<td>@ApiModelProperty(value = &quot;xxx属性说明&quot;,hidden = true)</td>
<td style="text-align:center">作用在类方法和属性上，hidden设置为true可以隐藏该属性</td>
</tr>
<tr>
<td>@ApiParam(&quot;xxx参数说明&quot;)</td>
<td style="text-align:center">作用在参数、方法和字段上，类似@ApiModelProperty</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于本站]]></title>
        <id>https://jayhablog.vercel.app/guan-yu-ben-zhan/</id>
        <link href="https://jayhablog.vercel.app/guan-yu-ben-zhan/">
        </link>
        <updated>2020-08-04T04:49:58.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站：</h2>
<p>这是Jayha小罗同学无聊之下做的一个简陋博客，旨在分享技术，倾吐垃圾，写矫情文字嘻嘻嘻。<br>
我也不知道我维护多久，可能写几篇之后就不写了（懒鬼本鬼谢谢!）也可能大学四年里一直维护他，将就看吧hhhhh。</p>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<p>跳舞唱歌敲代码！！！</p>
<h2 id="联系我呀">📬 联系我呀</h2>
<p>微信号: Jayha_<br>
gitee：https://gitee.com/jayha</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[简易快速springboot整合mybats步骤]]></title>
        <id>https://jayhablog.vercel.app/springboot-zheng-he-mybats-jian-yi/</id>
        <link href="https://jayhablog.vercel.app/springboot-zheng-he-mybats-jian-yi/">
        </link>
        <updated>2020-08-03T15:25:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id=""></h2>
<p>`mybatis整合</p>
<p>导入包不用说</p>
<p>在主运行类上 加上这个注解，表示给这个包都加上mapper注解</p>
<p>在yaml文件上配置mybatis配置</p>
<pre><code class="language-java">@MapperScan(basePackages ={&quot;cn.gdouJayha.springbootApplication.dao&quot;})
</code></pre>
<pre><code class="language-yaml">mybatis:
  #起别名
  type-aliases-package: cn.gdouJayha.springbootapplication.domain
  #映射位置
  mapper-locations: classpath:mybatis/mapper/*.xml
  
  check-config-location: true
  #主配置xml位置
  config-location: classpath:mybatis/SqlMapConfig.xml
</code></pre>
<h2 id="-2"></h2>
<p>更改pom.xml</p>
<pre><code class="language-xml">&lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
        &lt;resources&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/resources&lt;/directory&gt;
                &lt;!-- src/main/resources下的指定资源放行 --&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.*&lt;/include&gt;
                &lt;/includes&gt;
                &lt;filtering&gt;false&lt;/filtering&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
    &lt;/build&gt;
</code></pre>
<p>如果需要用到事务尽量用<br>
@EnableTransactionManagement开启事务</p>
<pre><code class="language-java">@Transactional
</code></pre>
<p>该注解放在方法上开启事务</p>
]]></content>
    </entry>
</feed>