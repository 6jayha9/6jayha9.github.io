<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jayhablog.vercel.app</id>
    <title>Jayha小罗的秘密基地</title>
    <updated>2020-10-22T12:30:18.023Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jayhablog.vercel.app"/>
    <link rel="self" href="https://jayhablog.vercel.app/atom.xml"/>
    <subtitle>欢迎来到Jayha小罗的Blog嘻嘻嘻：）</subtitle>
    <logo>https://jayhablog.vercel.app/images/avatar.png</logo>
    <icon>https://jayhablog.vercel.app/favicon.ico</icon>
    <rights>All rights reserved 2020, Jayha小罗的秘密基地</rights>
    <entry>
        <title type="html"><![CDATA[算法归纳]]></title>
        <id>https://jayhablog.vercel.app/kuai-man-zhi-zhen/</id>
        <link href="https://jayhablog.vercel.app/kuai-man-zhi-zhen/">
        </link>
        <updated>2020-10-22T12:29:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="快慢指针">快慢指针</h2>
<h4 id="floyd判圈算法龟兔赛跑算法">floyd判圈算法（龟兔赛跑算法）</h4>
<blockquote>
<p>遇到场合：判断链表是否循环</p>
</blockquote>
<h6 id="算法描述">算法描述：</h6>
<p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p>
<p>即有两个指针，他们速度不同 如 A指针=A指针.next B指针=B指针.next.next 那么他们肯定会相遇</p>
<pre><code class="language-java">public boolean hasCycle(ListNode head){
        if (head == null || head.next == null) {
            return false;//只有两个时候不用判断
        }
        ListNode A= head;//慢指针（乌龟指针）
        ListNode B =head.next;//快指针（兔子指针）
        while(A != B){
        if (B == null|| B.next==null){
            return  false;
        }
            A= A.next;
            B=B.next.next;
        }
        return  true;
</code></pre>
<p>时间复杂度O（N）</p>
<p>空间复杂度O（1）</p>
<hr>
<h2 id="贪心算法">贪心算法</h2>
<p>划分字母区间</p>
<p>题目</p>
<blockquote>
<blockquote>
<p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。</p>
<p>示例 1：</p>
<p>输入：S = &quot;ababcbacadefegdehijhklij&quot;<br>
输出：[9,7,8]<br>
解释：<br>
划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。<br>
每个字母最多出现在一个片段中。<br>
像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。</p>
<p>来源：力扣（LeetCode）<br>
链接：https://leetcode-cn.com/problems/partition-labels<br>
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
</blockquote>
<p>该题使用贪心算法，具体思路为，先把字符串中出现的char，将他们最后出现的下标保存在一个长度为26（因为有26个字母）的数组内</p>
<pre><code class="language-java">for (int i = 0; i &lt; 所给定字符串.length; i++) {
            last[S.charAt(i) - 'a'] = i;
        }
</code></pre>
<p>然后设置两个指针start和end，初始时为0，然后</p>
<pre><code class="language-java">end = Math.max(end, last[S.charAt(i) - 'a']);
</code></pre>
<p>end不断更新为i字符在该字符串的最后位置，如果在i！=end时候有字符还有更后的最后位置，那么end就会更新为该字符的最后位置。</p>
<p>如果i==end时候，就代表获取了这个字符区间长度（因为前面的字符都不会在剩余的字符串中出现，可以切的尽量多）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[redis作为nosql的使用（详细）与集成到springboot缓存]]></title>
        <id>https://jayhablog.vercel.app/redis-zuo-wei-nosql-de-shi-yong-xiang-xi-yu-ji-cheng-dao-springboot-huan-cun/</id>
        <link href="https://jayhablog.vercel.app/redis-zuo-wei-nosql-de-shi-yong-xiang-xi-yu-ji-cheng-dao-springboot-huan-cun/">
        </link>
        <updated>2020-10-22T12:27:01.000Z</updated>
        <content type="html"><![CDATA[<p>声明 由于本文部分借鉴菜鸟教程redis教程 https://www.runoob.com/redis/redis-geo.html</p>
<p>侵删。</p>
<h2 id="redis概述">redis概述</h2>
<p>redis是典型的noSQL数据库，以 <mark>key-value键值对</mark> 的方式存储数据，默认端口为6379</p>
<p>可以用来作<strong>数据库、缓存、消息中间件</strong></p>
<p>特点-&gt;</p>
<ul>
<li>基于内存实现</li>
<li>以单线程方式实现</li>
<li>默认有16个数据库</li>
</ul>
<p>redis可以设置成常开状态</p>
<p>首先 在shell界面启动进入redis命令为</p>
<pre><code class="language-bash">redis-cli
</code></pre>
<p>在redis界面可以使用</p>
<pre><code class="language-bash">dbsize #查看数据库大小
select [value] #使用第几个数据库
keys * #查看所有的key
FLUSHDB #清空此数据库
exist [key] #该key是否存在
move [key] #把这个键值对移到另一个库
EXPIRE [KEY] [TIME] #设置key过期的时间
ttl [key] #查看key剩余时间
type [key] #查看该key的value是什么类型
del [key] #删除某个键值对
</code></pre>
<hr>
<p>…………………………………………………………………………………………………………………………………………………</p>
<hr>
<h2 id="redis五大类型">redis五大类型</h2>
<blockquote>
<p>String类型</p>
</blockquote>
<pre><code class="language-bash">incr [key] #让他自增1
decr [key] #让他自减1
INCRBY [KEY] [NUM] #自增NUM个值 DECRBY同理
GETRANGE [KEY] [从哪开始] [从哪结束] #相当于substr
append [key] [string] #相当于java的append
SETRANGE [KEY] [STRING] #相当于substr＆replace
setex #设置过期时间
setnx #如果该key不存在才赋值
mset #一次设置多个键值对
mget #一次获取多个值
msetnx #看上面就知道什么意思了 只是这是个原子性操作（即只有成功或失败 没有一部分成功一部分失败）
getset #获取完这个值后再set这个值
set key value #存放键值对
</code></pre>
<p>因为json字符串也是String 存对象常用json字符串</p>
<p>或者以 <mark><em>[实体类]:[对象名]:[属性] [值]</em></mark> 多个属性 一个对象名 这种方式存储一个对象</p>
<hr>
<blockquote>
<p>List类型</p>
</blockquote>
<p>把list看作一个链表</p>
<p>L代表从左边 R代表从右边</p>
<p>有-》</p>
<pre><code class="language-bash">LPUSH [key] [value...] #创建链表/从左边插入数据 Rpush即从右边
Lrange [key] [start] [end] #序号开始 从左边开始遍历 Rrange即从右边
LPOP [key] [n] #从左边移出去n个值
Lindex #通过下标获取值 （从0开始 上面的从1开始）
Lrem #移除
#这些命令也可以组合
Lset #替换某个下标的值
Linsert #在某一个具体的值前面或者后面插入一个新的值
</code></pre>
<hr>
<blockquote>
<p>Set 类型</p>
</blockquote>
<table>
<thead>
<tr>
<th>1</th>
<th style="text-align:center">SADD key member1 [member2]向集合添加一个或多个成员</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td style="text-align:center"><a href="https://www.runoob.com/redis/sets-scard.html">SCARD key</a>  获取集合的成员数</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">[SDIFF key1 <a href="https://www.runoob.com/redis/sets-sdiff.html">key2]</a>  返回第一个集合与其他集合之间的差异。</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center">[SDIFFSTORE destination key1 <a href="https://www.runoob.com/redis/sets-sdiffstore.html">key2]</a>  返回给定所有集合的差集并存储在 destination 中</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:center">[SINTER key1 <a href="https://www.runoob.com/redis/sets-sinter.html">key2]</a>  返回给定所有集合的交集</td>
</tr>
<tr>
<td>6</td>
<td style="text-align:center">[SINTERSTORE destination key1 <a href="https://www.runoob.com/redis/sets-sinterstore.html">key2]</a>  返回给定所有集合的交集并存储在 destination 中</td>
</tr>
<tr>
<td>7</td>
<td style="text-align:center"><a href="https://www.runoob.com/redis/sets-sismember.html">SISMEMBER key member</a>  判断 member 元素是否是集合 key 的成员</td>
</tr>
<tr>
<td>8</td>
<td style="text-align:center"><a href="https://www.runoob.com/redis/sets-smembers.html">SMEMBERS key</a>  返回集合中的所有成员</td>
</tr>
<tr>
<td>9</td>
<td style="text-align:center"><a href="https://www.runoob.com/redis/sets-smove.html">SMOVE source destination member</a>  将 member 元素从 source 集合移动到 destination 集合</td>
</tr>
<tr>
<td>10</td>
<td style="text-align:center"><a href="https://www.runoob.com/redis/sets-spop.html">SPOP key</a>  移除并返回集合中的一个随机元素</td>
</tr>
<tr>
<td>11</td>
<td style="text-align:center">[SRANDMEMBER key <a href="https://www.runoob.com/redis/sets-srandmember.html">count]</a>  返回集合中一个或多个随机数</td>
</tr>
<tr>
<td>12</td>
<td style="text-align:center">[SREM key member1 <a href="https://www.runoob.com/redis/sets-srem.html">member2]</a>  移除集合中一个或多个成员</td>
</tr>
<tr>
<td>13</td>
<td style="text-align:center">[SUNION key1 <a href="https://www.runoob.com/redis/sets-sunion.html">key2]</a>  返回所有给定集合的并集</td>
</tr>
<tr>
<td>14</td>
<td style="text-align:center">[SUNIONSTORE destination key1 <a href="https://www.runoob.com/redis/sets-sunionstore.html">key2]</a>  所有给定集合的并集存储在 destination 集合中</td>
</tr>
<tr>
<td>15</td>
<td style="text-align:center">[SSCAN key cursor <a href="https://www.runoob.com/redis/sets-sscan.html">MATCH pattern] [COUNT count]</a>  迭代集合中的元素</td>
</tr>
</tbody>
</table>
<hr>
<blockquote>
<p>Hash类型</p>
</blockquote>
<p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p>
<table>
<thead>
<tr>
<th>1</th>
<th style="text-align:center">[HDEL key field1 <a href="https://www.runoob.com/redis/hashes-hdel.html">field2]</a>  删除一个或多个哈希表字段</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td style="text-align:center">hset key [filed value...] 创建hash</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center"><a href="https://www.runoob.com/redis/hashes-hexists.html">HEXISTS key field</a>  查看哈希表 key 中，指定的字段是否存在。</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center"><a href="https://www.runoob.com/redis/hashes-hget.html">HGET key field</a>  获取存储在哈希表中指定字段的值。</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center"><a href="https://www.runoob.com/redis/hashes-hgetall.html">HGETALL key</a>  获取在哈希表中指定 key 的所有字段和值</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:center"><a href="https://www.runoob.com/redis/hashes-hincrby.html">HINCRBY key field increment</a>  为哈希表 key 中的指定字段的整数值加上增量 increment 。</td>
</tr>
<tr>
<td>6</td>
<td style="text-align:center"><a href="https://www.runoob.com/redis/hashes-hincrbyfloat.html">HINCRBYFLOAT key field increment</a>  为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</td>
</tr>
<tr>
<td>7</td>
<td style="text-align:center"><a href="https://www.runoob.com/redis/hashes-hkeys.html">HKEYS key</a>  获取所有哈希表中的字段</td>
</tr>
<tr>
<td>8</td>
<td style="text-align:center"><a href="https://www.runoob.com/redis/hashes-hlen.html">HLEN key</a>  获取哈希表中字段的数量</td>
</tr>
<tr>
<td>9</td>
<td style="text-align:center">[HMGET key field1 <a href="https://www.runoob.com/redis/hashes-hmget.html">field2]</a>  获取所有给定字段的值</td>
</tr>
<tr>
<td>10</td>
<td style="text-align:center">[HMSET key field1 value1 <a href="https://www.runoob.com/redis/hashes-hmset.html">field2 value2 ]</a>  同时将多个 field-value (域-值)对设置到哈希表 key 中。</td>
</tr>
<tr>
<td>11</td>
<td style="text-align:center"><a href="https://www.runoob.com/redis/hashes-hset.html">HSET key field value</a>  将哈希表 key 中的字段 field 的值设为 value 。</td>
</tr>
<tr>
<td>12</td>
<td style="text-align:center"><a href="https://www.runoob.com/redis/hashes-hsetnx.html">HSETNX key field value</a>  只有在字段 field 不存在时，设置哈希表字段的值。</td>
</tr>
<tr>
<td>13</td>
<td style="text-align:center"><a href="https://www.runoob.com/redis/hashes-hvals.html">HVALS key</a>  获取哈希表中所有值。</td>
</tr>
<tr>
<td>14</td>
<td style="text-align:center">[HSCAN key cursor <a href="https://www.runoob.com/redis/hashes-hscan.html">MATCH pattern] [COUNT count]</a>  迭代哈希表中的键值</td>
</tr>
</tbody>
</table>
<blockquote>
<p>有序集合zset</p>
</blockquote>
<p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。</p>
<p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>有序集合的成员是唯一的,但分数(score)却可以重复。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<table>
<thead>
<tr>
<th>1</th>
<th>[ZADD key score1 member1 <a href="https://www.runoob.com/redis/sorted-sets-zadd.html">score2 member2]</a>  向有序集合添加一个或多个成员，或者更新已存在成员的分数</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td><a href="https://www.runoob.com/redis/sorted-sets-zcard.html">ZCARD key</a>  获取有序集合的成员数</td>
</tr>
<tr>
<td>3</td>
<td><a href="https://www.runoob.com/redis/sorted-sets-zcount.html">ZCOUNT key min max</a>  计算在有序集合中指定区间分数的成员数</td>
</tr>
<tr>
<td>4</td>
<td><a href="https://www.runoob.com/redis/sorted-sets-zincrby.html">ZINCRBY key increment member</a>  有序集合中对指定成员的分数加上增量 increment</td>
</tr>
<tr>
<td>5</td>
<td>[ZINTERSTORE destination numkeys key <a href="https://www.runoob.com/redis/sorted-sets-zinterstore.html">key ...]</a>  计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中</td>
</tr>
<tr>
<td>6</td>
<td><a href="https://www.runoob.com/redis/sorted-sets-zlexcount.html">ZLEXCOUNT key min max</a>  在有序集合中计算指定字典区间内成员数量</td>
</tr>
<tr>
<td>7</td>
<td>[ZRANGE key start stop <a href="https://www.runoob.com/redis/sorted-sets-zrange.html">WITHSCORES]</a>  通过索引区间返回有序集合指定区间内的成员</td>
</tr>
<tr>
<td>8</td>
<td>[ZRANGEBYLEX key min max <a href="https://www.runoob.com/redis/sorted-sets-zrangebylex.html">LIMIT offset count]</a>  通过字典区间返回有序集合的成员</td>
</tr>
<tr>
<td>9</td>
<td>[ZRANGEBYSCORE key min max <a href="https://www.runoob.com/redis/sorted-sets-zrangebyscore.html">WITHSCORES] [LIMIT]</a>  通过分数返回有序集合指定区间内的成员</td>
</tr>
<tr>
<td>10</td>
<td><a href="https://www.runoob.com/redis/sorted-sets-zrank.html">ZRANK key member</a>  返回有序集合中指定成员的索引</td>
</tr>
<tr>
<td>11</td>
<td>[ZREM key member <a href="https://www.runoob.com/redis/sorted-sets-zrem.html">member ...]</a>  移除有序集合中的一个或多个成员</td>
</tr>
<tr>
<td>12</td>
<td><a href="https://www.runoob.com/redis/sorted-sets-zremrangebylex.html">ZREMRANGEBYLEX key min max</a>  移除有序集合中给定的字典区间的所有成员</td>
</tr>
<tr>
<td>13</td>
<td><a href="https://www.runoob.com/redis/sorted-sets-zremrangebyrank.html">ZREMRANGEBYRANK key start stop</a>  移除有序集合中给定的排名区间的所有成员</td>
</tr>
<tr>
<td>14</td>
<td><a href="https://www.runoob.com/redis/sorted-sets-zremrangebyscore.html">ZREMRANGEBYSCORE key min max</a>  移除有序集合中给定的分数区间的所有成员</td>
</tr>
<tr>
<td>15</td>
<td>[ZREVRANGE key start stop <a href="https://www.runoob.com/redis/sorted-sets-zrevrange.html">WITHSCORES]</a>  返回有序集中指定区间内的成员，通过索引，分数从高到低</td>
</tr>
<tr>
<td>16</td>
<td>[ZREVRANGEBYSCORE key max min <a href="https://www.runoob.com/redis/sorted-sets-zrevrangebyscore.html">WITHSCORES]</a>  返回有序集中指定分数区间内的成员，分数从高到低排序</td>
</tr>
<tr>
<td>17</td>
<td><a href="https://www.runoob.com/redis/sorted-sets-zrevrank.html">ZREVRANK key member</a>  返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td>
</tr>
<tr>
<td>18</td>
<td><a href="https://www.runoob.com/redis/sorted-sets-zscore.html">ZSCORE key member</a>  返回有序集中，成员的分数值</td>
</tr>
<tr>
<td>19</td>
<td>[ZUNIONSTORE destination numkeys key <a href="https://www.runoob.com/redis/sorted-sets-zunionstore.html">key ...]</a>  计算给定的一个或多个有序集的并集，并存储在新的 key 中</td>
</tr>
<tr>
<td>20</td>
<td>[ZSCAN key cursor <a href="https://www.runoob.com/redis/sorted-sets-zscan.html">MATCH pattern] [COUNT count]</a>  迭代有序集合中的元素（包括元素成员和元素分值）</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="另外的类型">另外的类型</h2>
<blockquote>
<p>geospatial 地理位置</p>
</blockquote>
<pre><code class="language-bash">geoadd [国家]:city/town/... [区域名] [经纬度坐标] #添加一个城市/镇/街信息 [国家]:[什么区域]是key [区域名]是member 
</code></pre>
<p>但一般不用自己添加 使用java程序下载数据集一次性导入</p>
<pre><code class="language-bash">geopos [key] [member] #获取指定的经纬度
 GEODIST key member1 member2 [unit] #获取两者之间的距离 [unit]可以是km m dm ft（英尺） mi（英里）
 georadius #已给定经纬度为中心，找出某一个半径内的元素
 geohash #将经纬度坐标转换成hash字符串
 
</code></pre>
<p>其底层是zset 可以使用zset指令操作geospatial</p>
<hr>
<blockquote>
<p>HyperLogLog基数</p>
</blockquote>
<p>该元素是基数统计的算法</p>
<p>网页的UV（即一个人访问一个网站多次，还是算作一个人访问）</p>
<p>传统方式，set方式保存用户id，统计set元素数量作为判断。</p>
<p>HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。(12kb)</p>
<p>但有错误率(0.81％)</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>[PFADD key element <a href="https://www.runoob.com/redis/hyperloglog-pfadd.html">element ...]</a>  添加指定元素到 HyperLogLog 中。</td>
</tr>
<tr>
<td>2</td>
<td>[PFCOUNT key <a href="https://www.runoob.com/redis/hyperloglog-pfcount.html">key ...]</a>  返回给定 HyperLogLog 的基数估算值。</td>
</tr>
<tr>
<td>3</td>
<td>[PFMERGE destkey sourcekey <a href="https://www.runoob.com/redis/hyperloglog-pfmerge.html">sourcekey ...]</a>  将多个 HyperLogLog 合并为一个 HyperLogLog</td>
</tr>
</tbody>
</table>
<hr>
<p>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</p>
<hr>
<blockquote>
<p>事务</p>
</blockquote>
<p>redis事务不能保证原子性 使用multi命令开启 exec执行，一条语句错误不影响其他语句的执行</p>
<h2 id="springboot集成redis">springboot集成redis</h2>
<p>springboot2.x后 对redis的 底层放弃了jedis改采用lettuce</p>
<p>jedis：采用的是直连的server，多个线程操作的情况下，没有锁会不安全。</p>
<p>lettuce：底层采用netty，是NIO，实例可在多线程共享，多线程情况下也安全。</p>
<p>spring使用redisTemplate的方式操作redis，需要注意的是redisTemplate没有过多的设置，所以redis<strong>对象需要序列化</strong>，implements Serializable的方式固然可以存取值。但这只是在jdk中序列化，直接在redis仓库中查看会乱码，所以我们采用部分转化成String，部分转化成json的方式进行储存对象。（下面代码为固定模板，直接套用即可）</p>
<pre><code class="language-java">import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import javax.xml.transform.Templates;
@Configuration
public class redisConfig {
    /**
     * 自定义redisTemplate 使之序列化到redis仓库不乱码
     * @param redisConnectionFactory
     * @return
     */
    @Bean
    @SuppressWarnings(&quot;all&quot;)
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;();
        template.setConnectionFactory(factory);
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();

        // key采用String的序列化方式
        template.setKeySerializer(stringRedisSerializer);
        // hash的key也采用String的序列化方式
        template.setHashKeySerializer(stringRedisSerializer);
        // value序列化方式采用jackson
        template.setValueSerializer(jackson2JsonRedisSerializer);
        // hash的value序列化方式采用jackson
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        template.afterPropertiesSet();

        return template;

    }
}
</code></pre>
<p>之后</p>
<p>在application.yaml里配置有关redis的属性</p>
<pre><code class="language-yaml">spring:
  redis:
    host: 8.129.58.219
    password: djiowandijd
    client-name: redisClient
    lettuce:
      pool:
        max-active: 8
</code></pre>
<p>再之后，就可以用redistemplate封装的各种方法，操作各种类型的数据了，例如</p>
<pre><code class="language-java">Customer testCustomer = new Customer(1, &quot;imgLocaltion&quot;, 1, &quot;testAccount&quot;, &quot;testPassword&quot;, 200d, &quot;testName&quot;, &quot;testPhone&quot;, 2);
        redisTemplate.opsForValue().set(&quot;jayhaKey1&quot;,testCustomer);
        System.out.println(redisTemplate.opsForValue().get(&quot;jayhaKey1&quot;));
</code></pre>
<h2 id="springboot缓存抽象重点">springboot缓存抽象<mark>重点</mark></h2>
<p>spring定义了cache和cachemanager接口来统一不同的注解技术，并支持使用Jcache（JSR107</p>
<p>)注解简化开发</p>
<pre><code class="language-java">@Cacheable //主要针对方法配置，将结果进行缓存 主要用于查询的方法上
@CacheEvict //清空缓存 主要用于delete
@CachePut //保证方法被调用，又缓存 主要用于update
@EnableCaching //开启缓存注解支持
</code></pre>
<p>三个注解都有”value“属性， value属性相同时即是同一个缓存</p>
<h3 id="cacheable">Cacheable</h3>
<p>将方法的运行结果进行缓存;以后再要相同的数据,直接从缓存中获取,不用调用方法:<br>
CacheManager管理多个Cache组件的,对缓存的真正CRUD操作在Cache组件中,每一个缓存组件有自己唯一一个名字;</p>
<p>cacheable几个属性:<br>
cacheNames/value:指定缓存组件的名字;可以是多个</p>
<p>key:缓存数据使用的key;可以用它来指定。默认是使用方法参数的值 1-方法的返回值</p>
<p>编写SPEL; #id;参数id的值<br>
例如#root.method.name获取方法名  #root.args[0]获取参数 #result 结果 #result.id 结果对象的id<br>
keyGenerator: key的生成器;可以自己指定key的生成器的组件id key/keyGenerator: 二选一</p>
<p>cacheManager:指定缓存管理器;或者cacheResol ver指定获取解析器<br>
condition:指定符合条件的情况下才缓存:<br>
unless:否定缓存;当unless指定的条件为true,方法的返回值就不会被缓存;可以获取到结果进行判断<br>
unless = &quot;#result == null&quot;<br>
sync:是否使用异步模式</p>
<h3 id="cacheput">CachePut</h3>
<p>主要放在更新的方法上</p>
<p>在cachePut注解中，可以key指定为“#result.id(主键)”达到更新数据库同时更新缓存的目的</p>
<h3 id="cacheevict">CacheEvict</h3>
<p>主要用于删除的方法上，直接删除这个数据的缓存。</p>
<h3 id="caching">Caching</h3>
<p>上面三个注解的组合注解，适用于较为复杂的缓存</p>
<h3 id="cacheconfig">CacheConfig</h3>
<p>放在service类上 抽取缓存公共配置</p>
<p>比如cacheName等于其他注解的value 该类下所有cache的value都会变成这个</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[redis面试题]]></title>
        <id>https://jayhablog.vercel.app/redis-mian-shi-ti/</id>
        <link href="https://jayhablog.vercel.app/redis-mian-shi-ti/">
        </link>
        <updated>2020-10-22T12:23:36.000Z</updated>
        <content type="html"><![CDATA[<p>搬运自https://blog.csdn.net/Butterfly_resting/article/details/89668661</p>
<p>本文的面试题如下：<br>
Redis 持久化机制<br>
缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题<br>
热点数据和冷数据是什么<br>
Memcache与Redis的区别都有哪些？<br>
单线程的redis为什么这么快<br>
redis的数据类型，以及每种数据类型的使用场景，Redis 内部结构<br>
redis的过期策略以及内存淘汰机制【～】<br>
Redis 为什么是单线程的，优点<br>
如何解决redis的并发竞争key问题<br>
Redis 集群方案应该怎么做？都有哪些方案？<br>
有没有尝试进行多机redis 的部署？如何保证数据一致的？<br>
对于大量的请求怎么样处理<br>
Redis 常见性能问题和解决方案？<br>
讲解下Redis线程模型<br>
为什么Redis的操作是原子性的，怎么保证原子性的？<br>
Redis事务<br>
Redis实现分布式锁</p>
<hr>
<h2 id="redis-持久化机制">Redis 持久化机制</h2>
<p>Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。<br>
实现：单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。</p>
<p><strong>RDB</strong>是Redis默认的持久化方式。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即Snapshot快照存储，对应产生的数据文件为dump.rdb，通过配置文件中的save参数来定义快照的周期。（ 快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。）<br>
<strong>AOF</strong>：Redis会将每一个收到的写命令都通过Write函数追加到文件最后，类似于MySQL的binlog。当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。<br>
当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。</p>
<h2 id="缓存雪崩-缓存穿透-缓存预热-缓存更新-缓存降级等问题">缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题</h2>
<p><strong>缓存雪崩</strong>我们可以简单的理解为：由于原有缓存失效，新缓存未到期间<br>
(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。<br>
<strong>解决办法</strong>：<br>
大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开。</p>
<p>二、<strong>缓存穿透</strong><br>
缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。<br>
<strong>解决办法;</strong><br>
最常见的则是采用<strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。<br>
另外也有一个更为<strong>简单粗暴的方法</strong>，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。<br>
5TB的硬盘上放满了数据，请写一个算法将这些数据进行排重。如果这些数据是一些32bit大小的数据该如何解决？如果是64bit的呢？</p>
<p>对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。<br>
Bitmap： 典型的就是哈希表<br>
缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。</p>
<p><strong>布隆过滤器（推荐）</strong><br>
就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。<br>
它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。<br>
Bloom-Filter算法的<strong>核心思想</strong>就是利用多个不同的Hash函数来解决“冲突”。<br>
Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。<br>
Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。<br>
<strong>受提醒补充：缓存穿透与缓存击穿的区别</strong><br>
<strong>缓存击穿</strong>：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据。<br>
解决方案;在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。<br>
增：给一个我公司处理的案例：背景双机拿token，token在存一份到redis，保证系统在token过期时都只有一个线程去获取token;线上环境有两台机器，故使用分布式锁实现。</p>
<p>三、<strong>缓存预热</strong><br>
缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！<br>
解决思路：<br>
1、直接写个缓存刷新页面，上线时手工操作下；<br>
2、数据量不大，可以在项目启动的时候自动进行加载；<br>
3、定时刷新缓存；</p>
<p>四、<strong>缓存更新</strong><br>
除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：<br>
（1）定时去清理过期的缓存；<br>
（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。<br>
两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。<br>
五、<strong>缓存降级</strong><br>
当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。<br>
降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。<br>
以参考日志级别设置预案：<br>
（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；<br>
（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；<br>
（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；<br>
（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p>
<p>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</p>
<h2 id="热点数据和冷数据是什么">热点数据和冷数据是什么</h2>
<p>热点数据，缓存才有价值<br>
对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存<br>
对于上面两个例子，寿星列表、导航信息都存在一个特点，就是信息修改频率不高，读取通常非常高的场景。<br>
对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。<br>
**数据更新前至少读取两次，**缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。<br>
那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。</p>
<h2 id="memcache与redis的区别都有哪些">Memcache与Redis的区别都有哪些？</h2>
<p>1)、存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，redis可以持久化其数据<br>
2)、数据支持类型 memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 ，提供list，set，zset，hash等数据结构的存储<br>
3)、使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。<br>
4). value 值大小不同：Redis 最大可以达到 512M；memcache 只有 1mb。<br>
5）redis的速度比memcached快很多<br>
6）Redis支持数据的备份，即master-slave模式的数据备份。</p>
<h2 id="单线程的redis为什么这么快">单线程的redis为什么这么快</h2>
<p>(一)纯内存操作<br>
(二)单线程操作，避免了频繁的上下文切换<br>
(三)采用了非阻塞I/O多路复用机制</p>
<h2 id="redis的数据类型以及每种数据类型的使用场景">redis的数据类型，以及每种数据类型的使用场景</h2>
<p>回答：一共五种<br>
(一)String<br>
这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。<br>
(二)hash<br>
这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。<br>
(三)list<br>
使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。本人还用一个场景，很合适—取行情信息。就也是个生产者和消费者的场景。LIST可以很好的完成排队，先进先出的原则。<br>
(四)set<br>
因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。<br>
另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。<br>
(五)sorted set<br>
sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。</p>
<h2 id="redis-内部结构">Redis 内部结构</h2>
<ul>
<li>dict 本质上是为了解决算法中的查找问题（Searching）是一个用于维护key和value映射关系的数据结构，与很多语言中的Map或dictionary类似。 本质上是为了解决算法中的查找问题（Searching）</li>
<li>sds sds就等同于char * 它可以存储任意二进制数据，不能像C语言字符串那样以字符’\0’来标识字符串的结 束，因此它必然有个长度字段。</li>
<li>skiplist （跳跃表） 跳表是一种实现起来很简单，单层多指针的链表，它查找效率很高，堪比优化过的二叉平衡树，且比平衡树的实现，</li>
<li>quicklist</li>
<li>ziplist 压缩表 ziplist是一个编码后的列表，是由一系列特殊编码的连续内存块组成的顺序型数据结构，</li>
</ul>
<h2 id="redis的过期策略以及内存淘汰机制">redis的过期策略以及内存淘汰机制</h2>
<p>redis采用的是<strong>定期删除+惰性删除策略</strong>。<br>
为什么不用定时删除策略?<br>
定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.<br>
<strong>定期删除+惰性删除是如何工作的呢?</strong><br>
定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。<br>
于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。<br>
采用定期删除+惰性删除就没其他问题了么?<br>
不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。<br>
在redis.conf中有一行配置</p>
<pre><code>maxmemory-policy volatile-lru
1
</code></pre>
<p>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)<br>
<strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰<br>
<strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰<br>
<strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰<br>
<strong>allkeys-lru</strong>：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰<br>
<strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰<br>
<strong>no-enviction</strong>（驱逐）：禁止驱逐数据，新写入操作会报错<br>
ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</p>
<h2 id="redis-为什么是单线程的">Redis 为什么是单线程的</h2>
<p>官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）Redis利用队列技术将并发访问变为串行访问<br>
1）绝大部分请求是纯粹的内存操作（非常快速）2）采用单线程,避免了不必要的上下文切换和竞争条件<br>
3）非阻塞IO优点：<br>
1.速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)<br>
\2. 支持丰富数据类型，支持string，list，set，sorted set，hash<br>
3.支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行<br>
\4. 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除如何解决redis的并发竞争key问题</p>
<p>同时有多个子系统去set一个key。这个时候要注意什么呢？  不推荐使用redis的事务机制。因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。<br>
(1)如果对这个key操作，不要求顺序： 准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可<br>
(2)如果对这个key操作，要求顺序： 分布式锁+时间戳。 假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。<br>
(3) 利用队列，将set方法变成串行访问也可以redis遇到高并发，如果保证读写key的一致性<br>
对redis的操作都是具有原子性的,是线程安全的操作,你不用考虑并发问题,redis内部已经帮你处理好并发的问题了。</p>
<h2 id="redis-集群方案应该怎么做都有哪些方案">Redis 集群方案应该怎么做？都有哪些方案？</h2>
<p>1.twemproxy，大概概念是，它类似于一个代理方式， 使用时在本需要连接 redis 的地方改为连接 twemproxy， 它会以一个代理的身份接收请求并使用一致性 hash 算法，将请求转接到具体 redis，将结果再返回 twemproxy。<br>
缺点： twemproxy 自身单端口实例的压力，使用一致性 hash 后，对 redis 节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。</p>
<p>2.codis，目前用的最多的集群方案，基本和 twemproxy 一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新 hash 节点</p>
<p>3.redis cluster3.0 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 hash 槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。</p>
<h2 id="有没有尝试进行多机redis-的部署如何保证数据一致的">有没有尝试进行多机redis 的部署？如何保证数据一致的？</h2>
<p>主从复制，读写分离<br>
一类是主数据库（master）一类是从数据库（slave），主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。</p>
<h2 id="对于大量的请求怎么样处理">对于大量的请求怎么样处理</h2>
<p>redis是一个单线程程序，也就说同一时刻它只能处理一个客户端请求；<br>
redis是通过IO多路复用（select，epoll, kqueue，依据不同的平台，采取不同的实现）来处理多个客户端请求的</p>
<h2 id="redis-常见性能问题和解决方案">Redis 常见性能问题和解决方案？</h2>
<p>(1) Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件<br>
(2) 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次<br>
(3) 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内<br>
(4) 尽量避免在压力很大的主库上增加从库<br>
(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即： Master &lt;- Slave1 &lt;- Slave2 &lt;-<br>
Slave3…</p>
<h2 id="讲解下redis线程模型">讲解下Redis线程模型</h2>
<p>文件事件处理器包括分别是<strong>套接字、 I/O 多路复用程序、 文件事件分派器（dispatcher）、 以及事件处理器</strong>。使用 I/O 多路复用程序来同时监听多个套接字，  并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。<br>
I/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。<br>
<strong>工作原理：</strong><br>
1)I/O 多路复用程序负责监听多个套接字， 并向文件事件分派器传送那些产生了事件的套接字。<br>
尽管多个文件事件可能会并发地出现， 但 I/O 多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面， 然后通过这个队列，  以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字：  当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O  多路复用程序才会继续向文件事件分派器传送下一个套接字。如果一个套接字又可读又可写的话， 那么服务器将先读套接字， 后写套接字.<br>
<img src="https://img-blog.csdnimg.cn/20190429094050254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0J1dHRlcmZseV9yZXN0aW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="为什么redis的操作是原子性的怎么保证原子性的">为什么Redis的操作是原子性的，怎么保证原子性的？</h2>
<p>对于Redis而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。<br>
Redis的操作之所以是原子性的，是因为Redis是单线程的。<br>
Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。<br>
多个命令在并发中也是原子性的吗？<br>
不一定， 将get和set改成单命令操作，incr 。使用Redis的事务，或者使用Redis+Lua==的方式实现.</p>
<h2 id="redis事务">Redis事务</h2>
<p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的<br>
Redis会将一个事务中的所有命令序列化，然后按顺序执行。<br>
1.redis 不支持回滚“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。<br>
2.如果在一个事务中的<strong>命令</strong>出现错误，那么<strong>所有的命令</strong>都不会执行；<br>
3.如果在一个事务中出现<strong>运行错误</strong>，那么<strong>正确的命令</strong>会被执行。<br>
注：redis的discard只是结束本次事务,正确命令造成的影响仍然存在.</p>
<p>1）MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。<br>
2）EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。<br>
3）通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。<br>
4）WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</p>
<h2 id="redis实现分布式锁">Redis实现分布式锁</h2>
<p>Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。<br>
将 key 的值设为 value ，当且仅当 key 不存在。 若给定的 key 已经存在，则 SETNX 不做任何动作<br>
<img src="https://img-blog.csdnimg.cn/20190429094250409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0J1dHRlcmZseV9yZXN0aW5n,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
解锁：使用 del key 命令就能释放锁<br>
解决死锁：<br>
1）通过Redis中expire()给锁设定最大持有时间，如果超过，则Redis来帮我们释放锁。<br>
2） 使用 setnx key “当前系统时间+锁持有的时间”和getset key “当前系统时间+锁持有的时间”组合的命令就可以实现</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[spring-security安全认证框架Part1（非OAuth2部分）]]></title>
        <id>https://jayhablog.vercel.app/spring-security-an-quan-ren-zheng-kuang-jia-1/</id>
        <link href="https://jayhablog.vercel.app/spring-security-an-quan-ren-zheng-kuang-jia-1/">
        </link>
        <updated>2020-09-13T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<hr>
<p>spring-security是通过servlet的filter链方式实现的一种认证，授权<br>
<img src="https://jayhablog.vercel.app/post-images/1599995513270.png" alt="" loading="lazy"><br>
快速入门（在内存中使用）；</p>
<p>在内存中的使用非常简单</p>
<p>阅读代码即可</p>
<pre><code class="language-java">@Configuration
@EnableWebSecurity
public class securityConfig extends WebSecurityConfigurerAdapter {

    @Bean
    public PasswordEncoder passwordEncoder() {
        // BCryptPasswordEncoder：Spring Security 提供的加密工具，可快速实现加密加盐
        return new BCryptPasswordEncoder();
    }
    @Bean
    public UserDetailsService userDetailsService(){
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        return  manager;
    }
    /**
     * 该方法是授权相关方法
     * @param http
     * @throws Exception
     */
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        //首页所有人可以访问&quot;/&quot;
        http.authorizeRequests()
                .antMatchers(&quot;/&quot;).permitAll()
                .antMatchers(&quot;/index.html&quot;).permitAll()
                .antMatchers(&quot;/index&quot;).permitAll()
                .antMatchers(&quot;/home&quot;).permitAll()
                .antMatchers(&quot;/welcome&quot;).permitAll()
                .antMatchers(&quot;/level1/**&quot;).hasRole(&quot;vip1&quot;)
                .antMatchers(&quot;/level2/**&quot;).hasRole(&quot;vip2&quot;)
                .antMatchers(&quot;/level3/**&quot;).hasRole(&quot;vip3&quot;)
        .and().formLogin()//开启自定义页面
                .loginPage(&quot;/userlogin&quot;).loginProcessingUrl(&quot;/welcome&quot;).usernameParameter(&quot;username&quot;).passwordParameter(&quot;password&quot;).
                failureHandler((req, resp, exception) -&gt; {
                    resp.setContentType(&quot;application/json;charset=utf-8&quot;);
                            PrintWriter out = resp.getWriter();
                            out.write(&quot;登录失败...&quot;);
                    out.flush();
                })
                .permitAll()
                .and()
                .httpBasic()
                .and()
                // 关闭CSRF跨域
                .csrf().disable();
        ;
        //没有权限跳到登录页
        /*http.formLogin();*/
        //关闭csrf功能
        //http.csrf().disable();
        //开启注销 成功跳到“/”
        http.logout().logoutSuccessUrl(&quot;/&quot;);
    }

    /**
     * 该方法是认证相关方法
     * @param auth
     * @throws Exception
     */
    /*@Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        //从内存中读
        //使用BCrypt加密

        auth.inMemoryAuthentication().passwordEncoder(passwordEncoder())
                .withUser(&quot;jayha&quot;).password(passwordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip3&quot;,&quot;vip2&quot;)
                .and()
                .withUser(&quot;nanha&quot;).password(passwordEncoder().encode(&quot;123456&quot;)).roles(&quot;vip1&quot;);

    }*/

    @Override
    public void configure(WebSecurity web) throws Exception {
        // 设置拦截忽略url - 会直接过滤该url - 将不会经过Spring Security过滤器链
        web.ignoring().antMatchers(&quot;/getUserInfo&quot;);
        // 设置拦截忽略文件夹，可以对静态资源放行
        web.ignoring().antMatchers(&quot;/css/**&quot;, &quot;/js/**&quot;);

    }
}
</code></pre>
<hr>
<hr>
<p>BCryptPasswordEncoder</p>
<p>是spring提供的一种特殊加密方式，建议数据库以次类方式存储，有静态方法hashpw(实际密码，盐分值[也可由Bcrypt自动生成])</p>
<pre><code class="language-java">void testBcrypto(){
        String s1 = BCrypt.hashpw(&quot;sir159357&quot;, BCrypt.gensalt());
        String s2 = BCrypt.hashpw(&quot;sir159357&quot;, BCrypt.gensalt());

        System.out.println(s1);
        System.out.println(s2);
    }
</code></pre>
<p>结果</p>
<pre><code class="language-tex">s1:$2a$10$WH2U/RLezICmMu8cAN2kQ.vWb46UOEtYbHgMeri8bc4JHGtKVGSKy

s2:$2a$10$aLTNf4pFC3OwyEM/r.9aeepuid9efVaLlvdqpNEDO01vPX.17kc0O
</code></pre>
<p>所以配置一个名为passwordEncoder的bean 该bean返回的值 就是security的编码方式</p>
<pre><code class="language-java">@Bean
    public PasswordEncoder passwordEncoder() {
        // BCryptPasswordEncoder：Spring Security 提供的加密工具，可快速实现加密加盐
        return new BCryptPasswordEncoder();
    }
</code></pre>
<p>接下来 我们就可以从内存过渡到数据库了</p>
<p>回到springsecurity流程图 我们可以发现认证是由一个叫做UserDetailsService的接口进行实现的。我们可以实现这个接口并把ta加入到IOC容器中</p>
<pre><code class="language-java">@Service
public class userdetailService implements UserDetailsService {

    @Autowired
    ItestuserDAO itestuserDAO;

    @Override
    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException {
        testuser one = itestuserDAO.findOneByAccount(s);
        if(one == null){
            return null;//不用自己抛出异常 返回NULL spring=security会自动整理
        }else{
            UserDetails details = User.withUsername(one.getAccount()).password(one.getPassword()).authorities(&quot;vip1&quot;).build();//withusername方法即把username加入 password同理，authorities则是将用户进行授权操作
            return details;
        }
    }
}
</code></pre>
<p>注意的是这里给用户授权的是auth 而在SecurityConfig里面是授权的role 二者是不同授权理念的具体实现，现在一般是role（角色）包含auth（权限）这种操作  要注意更改</p>
<p><s>俺最初没理解好这两个东西的概念在这疯狂踩坑</s></p>
<pre><code class="language-java">@Override
    protected void configure(HttpSecurity http) throws Exception {
        //首页所有人可以访问&quot;/&quot;
        http.authorizeRequests()
                .antMatchers(&quot;/&quot;).permitAll()
                .antMatchers(&quot;/index.html&quot;).permitAll()
                .antMatchers(&quot;/index&quot;).permitAll()
                .antMatchers(&quot;/home&quot;).permitAll()
                .antMatchers(&quot;/welcome&quot;).permitAll()
                .antMatchers(&quot;/level1/**&quot;).hasAuthority(&quot;vip1&quot;)
                .antMatchers(&quot;/level2/**&quot;).hasAuthority(&quot;vip2&quot;)
                .antMatchers(&quot;/level3/**&quot;).hasAuthority(&quot;vip3&quot;)
                .and()
                .formLogin()//开启自定义页面
                .loginPage(&quot;/userlogin&quot;)
                .loginProcessingUrl(&quot;/welcome&quot;)
                .usernameParameter(&quot;username&quot;)
                .passwordParameter(&quot;password&quot;)

                .failureHandler((req, resp, exception) -&gt; {
                    resp.setContentType(&quot;application/json;charset=utf-8&quot;);
                            PrintWriter out = resp.getWriter();
                            out.write(&quot;登录失败...&quot;);
                    out.flush();
                }).permitAll()
                .and()
                .httpBasic()
                .and()
                // 关闭CSRF跨域
                .csrf().disable().cors();
        ;
        http.logout().logoutSuccessUrl(&quot;/&quot;);
    }
</code></pre>
<h5 id="用户登录后获取用户信息">用户登录后获取用户信息</h5>
<p>可以使用</p>
<pre><code class="language-java">Authentication authentication =SecurityContextHolder.getContext().getAuthentication();
        Object principal = authentication.getPrincipal();
</code></pre>
<p>principal就是UserDetail对象 可以强转后使用它的各种方法 比如获取姓名：</p>
<pre><code class="language-java"> @GetMapping(&quot;/getName&quot;)
    public String getUserAccount(){
        String account= null;
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        Object principal = authentication.getPrincipal();
        if(principal == null){
            account = &quot;匿名&quot;;
        }
        if(principal instanceof UserDetails){
            UserDetails u = (UserDetails)principal;
            account = u.getUsername();
        }
        return account;
    }
</code></pre>
<p>数据库的建立 除了用户类外 还要有角色表 与用户表是多对多关系 还要有权限表 和角色表也是多对多关系由于这个sql比较复杂 建议用mybatis</p>
<p>由于我们之后使用token来保持会话，所以 我们可以将session保持会话方式禁用</p>
<p><s>建议在学了token之后再关</s></p>
<pre><code class="language-java">protected void configure(HttpSecurity http) throws Exception {http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);}
</code></pre>
<hr>
<h4 id="方法授权">方法授权</h4>
<p>在配置类上（加了configuration注解的类）使用</p>
<pre><code class="language-java">@EnableGlobalMethodSecurity(securedEnabled = true )
</code></pre>
<p>开启方法授权 secured注解API支持</p>
<pre><code class="language-java">@Secured(&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;)//允许匿名访问的方法（即任何人都可以访问）
@Secured(&quot;ROLE_xx&quot;)//只有xx角色的可以访问

</code></pre>
<p>但不建议使用这个</p>
<p>建议使用prepost注解</p>
<pre><code class="language-java">@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)
</code></pre>
<pre><code class="language-java">@PreAuthorize(&quot;isAnonymous()&quot;) 匿名可以访问
@PreAuthorize(&quot;hasAuthority('vip1','vip2')&quot;)有vip1和vip2的可以访问
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[springboot集成定时，异步，邮件任务]]></title>
        <id>https://jayhablog.vercel.app/springboot-ji-cheng-ding-shi-yi-bu-you-jian-ren-wu/</id>
        <link href="https://jayhablog.vercel.app/springboot-ji-cheng-ding-shi-yi-bu-you-jian-ren-wu/">
        </link>
        <updated>2020-09-11T06:35:16.000Z</updated>
        <content type="html"><![CDATA[<h2 id="异步">异步</h2>
<hr>
<p>springboot主类下用@EnableAsync 开启异步</p>
<p>在需要用异步的方法上使用@Async注解，该任务会自动进入一个新进程，自动异步</p>
<h2 id="邮件">邮件</h2>
<hr>
<p>jar</p>
<pre><code class="language-xml">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-mail --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;
&lt;/dependency&gt;

</code></pre>
<p>yaml配置信息</p>
<pre><code class="language-yaml">spring:
   mail:
     username: your_mail@xx.com
     password: your_password
     host: smtp.163.com  #example
     protocol: smtps   #example
</code></pre>
<p>springboot自动装JavaMailSenderImpl的实体类</p>
<pre><code class="language-java">//源码
@Bean
    JavaMailSenderImpl mailSender(Session session) {
        JavaMailSenderImpl sender = new JavaMailSenderImpl();
        sender.setDefaultEncoding(this.properties.getDefaultEncoding().name());
        sender.setSession(session);
        return sender;
    }
</code></pre>
<p>按照配置文件的属性进行创建，可以直接注入</p>
<pre><code class="language-java"> @Autowired
    private JavaMailSenderImpl mailSender;
</code></pre>
<p>之后直接用mailsender所提供的各种send进行发送就行 示例：</p>
<pre><code class="language-java">@Test
    void contextLoads()  {
        SimpleMailMessage mailMessage = new SimpleMailMessage();
        mailMessage.setSubject(&quot;早上好&quot;);
        mailMessage.setText(&quot;goodMoring&quot;);
        mailMessage.setTo(&quot;send_mail@qq.com&quot;);
        mailMessage.setFrom(&quot;your_mail@163.com&quot;);
        mailSender.send(mailMessage);
    }
</code></pre>
<p>若要发送复杂邮件 则可以取消simpleMailMessage类 用</p>
<pre><code class="language-java">MimeMessage mimeMessage = mailSender.createMimeMessage();
</code></pre>
<p>复杂类对象</p>
<pre><code class="language-java">        MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true);

        helper.setSubject(&quot;早上好&quot;);
        helper.setText(&quot;&lt;a herf='www.baidu.com' &gt;今天 7:30来开会&lt;/a&gt;&quot;,true);

        //发送附件
        helper.addAttachment(&quot;1.jpg&quot;,new File(&quot;C:\\Users\\19029\\Desktop\\杂七杂八~\\1.jpg&quot;));

        helper.setTo(&quot;1902980268@qq.com&quot;);
        helper.setFrom(&quot;15999971548@163.com&quot;);
        mailSender.send(mimeMessage);
</code></pre>
<h2 id="定时">定时</h2>
<hr>
<p>项目开发中经常需要执行一些定时任务，比如需要在每天凌晨的时候，分析一次前一天的日志信息，Spring为我们提供了异步执行任务调度的方式，提供了两个接口。</p>
<ul>
<li>TaskExecutor接口</li>
<li>TaskScheduler接口</li>
</ul>
<p>两个注解：</p>
<ul>
<li>@EnableScheduling// 主main方法上 表示开启定时任务</li>
<li>@Scheduled//写cron表达式 表示什么时候</li>
</ul>
<figure data-type="image" tabindex="1"><img src="C:%5CUsers%5C19029%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200911141657793.png" alt="image-20200911141657793" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[swagger初步实践]]></title>
        <id>https://jayhablog.vercel.app/swagger-chu-bu-shi-jian/</id>
        <link href="https://jayhablog.vercel.app/swagger-chu-bu-shi-jian/">
        </link>
        <updated>2020-09-10T08:04:11.000Z</updated>
        <content type="html"><![CDATA[<h3 id="swagger">swagger</h3>
<hr>
<p>swagger jar</p>
<pre><code class="language-xml">&lt;!--swagger--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;
            &lt;version&gt;2.9.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--http://localhost:8080/swagger-ui.html--&gt;
        &lt;!--&lt;dependency&gt;
            &lt;groupId&gt;io.springfox&lt;/groupId&gt;
            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;
            &lt;version&gt;2.9.2&lt;/version&gt;
        &lt;/dependency&gt;--&gt;
        &lt;!--http://localhost:8080/document.html--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.zyplayer&lt;/groupId&gt;
            &lt;artifactId&gt;swagger-mg-ui&lt;/artifactId&gt;
            &lt;version&gt;1.0.6&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p><em>swagger的springboot内类配置</em></p>
<pre><code class="language-java">package cn.gdoujayha.springbootApplication.config;

import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.env.Environment;
import org.springframework.core.env.Profiles;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Contact;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

import java.util.ArrayList;
import java.util.Properties;


@Configuration
@EnableSwagger2
public class SwaggerConfig {

    /**
     * 联系方式（作者名字，联系url，email）
     */
    private static final Contact CONTACT = new Contact(&quot;jayha&quot;,&quot;https://jayhablog.vercel.app&quot;,&quot;1902980268@qq.com&quot;) ;

    /*
        配置swagger的docket bean实例
         */
    @Bean
    /*@ConditionalOnProperty(prefix = &quot;profiles&quot;,havingValue = &quot;dev&quot;)*/
    public Docket docket(Environment environment){


        Profiles profiles = Profiles.of(&quot;dev&quot;,&quot;test&quot;);
        boolean flag = environment.acceptsProfiles(profiles);//“仅在dev和test环境下生效”


       return  new Docket(DocumentationType.SWAGGER_2)
                .groupName(&quot;jayha&quot;)//设置分组名 可以设置多个分组（多人协同的时候，可以一人一个或多个组）
                .enable(flag)
                .apiInfo(apiInfo())
                .select()
                /**
                 * apis：配置所需要扫描的地方
                 * requestHandlerSelectors有方式
                 * .basePackage配置扫描包
                 * .any扫描所有地方
                 * .none全不扫描
                 * .withClassAnnotation()只扫描类上有加了传入注解class的的那个注解的类（传入注解的class）
                 */
                .apis(RequestHandlerSelectors.basePackage(&quot;cn.gdoujayha.springbootApplication.controller&quot;))//配置扫描包
                /**
                 * paths配置过滤的路径
                 * 使用pathselector下的东西
                 * 下有：
                 * any全部
                 * none全否
                 * regex：正则
                 * ant（一般用这个）路径
                 */
                //.paths(PathSelectors.ant(&quot;/springbootApplication/controller/reginController/**&quot;))
                .build()
                ;
    }

    /**
     * apiinfo的配置
     * @return
     */
    private ApiInfo apiInfo(){
        return new ApiInfo(&quot;Jayha‘文档&quot;,
                &quot;关于''项目的swagger文档&quot;,
                &quot;0.1&quot;,
                &quot;urn:tos&quot;,
                CONTACT,
                &quot;Apache 2.0&quot;,
                &quot;http://www.apache.org/licenses/LICENSE-2.0&quot;,
                new ArrayList());
    }
}

</code></pre>
<blockquote>
<h3 id="常用注解">常用注解</h3>
</blockquote>
<p>Swagger的所有注解定义在io.swagger.annotations包下</p>
<p>下面列一些经常用到的，未列举出来的可以另行查阅说明：</p>
<table>
<thead>
<tr>
<th>Swagger注解</th>
<th style="text-align:center">简单说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Api(tags = &quot;xxx模块说明&quot;)</td>
<td style="text-align:center">作用在模块类上</td>
</tr>
<tr>
<td>@ApiOperation(&quot;xxx接口说明&quot;)</td>
<td style="text-align:center">作用在接口方法上</td>
</tr>
<tr>
<td>@ApiModel(&quot;xxxPOJO说明&quot;)</td>
<td style="text-align:center">作用在模型类上：如VO、BO</td>
</tr>
<tr>
<td>@ApiModelProperty(value = &quot;xxx属性说明&quot;,hidden = true)</td>
<td style="text-align:center">作用在类方法和属性上，hidden设置为true可以隐藏该属性</td>
</tr>
<tr>
<td>@ApiParam(&quot;xxx参数说明&quot;)</td>
<td style="text-align:center">作用在参数、方法和字段上，类似@ApiModelProperty</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于本站]]></title>
        <id>https://jayhablog.vercel.app/guan-yu-ben-zhan/</id>
        <link href="https://jayhablog.vercel.app/guan-yu-ben-zhan/">
        </link>
        <updated>2020-08-04T04:49:58.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站：</h2>
<p>这是Jayha小罗同学无聊之下做的一个简陋博客，旨在分享技术，倾吐垃圾，写矫情文字嘻嘻嘻。<br>
我也不知道我维护多久，可能写几篇之后就不写了（懒鬼本鬼谢谢!）也可能大学四年里一直维护他，将就看吧hhhhh。</p>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<p>跳舞唱歌敲代码！！！</p>
<h2 id="联系我呀">📬 联系我呀</h2>
<p>微信号: Jayha_<br>
gitee：https://gitee.com/jayha</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[简易快速springboot整合mybats步骤]]></title>
        <id>https://jayhablog.vercel.app/springboot-zheng-he-mybats-jian-yi/</id>
        <link href="https://jayhablog.vercel.app/springboot-zheng-he-mybats-jian-yi/">
        </link>
        <updated>2020-08-03T15:25:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id=""></h2>
<p>`mybatis整合</p>
<p>导入包不用说</p>
<p>在主运行类上 加上这个注解，表示给这个包都加上mapper注解</p>
<p>在yaml文件上配置mybatis配置</p>
<pre><code class="language-java">@MapperScan(basePackages ={&quot;cn.gdouJayha.springbootApplication.dao&quot;})
</code></pre>
<pre><code class="language-yaml">mybatis:
  #起别名
  type-aliases-package: cn.gdouJayha.springbootapplication.domain
  #映射位置
  mapper-locations: classpath:mybatis/mapper/*.xml
  
  check-config-location: true
  #主配置xml位置
  config-location: classpath:mybatis/SqlMapConfig.xml
</code></pre>
<h2 id="-2"></h2>
<p>更改pom.xml</p>
<pre><code class="language-xml">&lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
        &lt;resources&gt;
            &lt;resource&gt;
                &lt;directory&gt;src/main/resources&lt;/directory&gt;
                &lt;!-- src/main/resources下的指定资源放行 --&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/*.*&lt;/include&gt;
                &lt;/includes&gt;
                &lt;filtering&gt;false&lt;/filtering&gt;
            &lt;/resource&gt;
        &lt;/resources&gt;
    &lt;/build&gt;
</code></pre>
<p>如果需要用到事务尽量用<br>
@EnableTransactionManagement开启事务</p>
<pre><code class="language-java">@Transactional
</code></pre>
<p>该注解放在方法上开启事务</p>
]]></content>
    </entry>
</feed>